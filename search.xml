<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C语言文件操作相关</title>
    <url>/2020/08/14/C%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<p>做课设时遇到的各种问题及其解决</p>
<a id="more"></a>

<h1 id="1-修改文件内容"><a href="#1-修改文件内容" class="headerlink" title="1.修改文件内容"></a>1.修改文件内容</h1><p>做课设的时候，需要用到 C 的文件操作，本意是想实现文件的<strong>覆盖写入</strong>（即修改文件内容但不改变文件大小），如下：</p>
<blockquote>
<p>原本文件内容为 abcdefg，现在第3位后写入123，写入后预期文件内容为abc123g</p>
</blockquote>
<p>但实际做出来的效果是<em>每次写完后文件大小都会改变</em>，恰巧我写的是二进制文件而不是文本文件（而且大小有10M），不好直接打开文件查看问题</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>调试后发现文件大小改变是因为最后一次写操作之后的内容都会丢失，此时考虑到是写操作的方式有问题，而写操作的方式是由函数<code>fopen</code>决定的</p>
<p>先来看看<code>fopen</code>的函数原型</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span> *mode)</span></span>;</span><br></pre></td></tr></table></figure>

<p>参数如下：</p>
<ul>
<li><em>filename</em>：字符串，包含了要打开的文件名称；</li>
<li><em>mode</em>：字符串，包含了文件访问模式；</li>
</ul>
<p>返回值为文件指针，在不同模式下的初始值不同</p>
<h2 id="问题的关键"><a href="#问题的关键" class="headerlink" title="问题的关键"></a>问题的关键</h2><p>显然，需要在意的是参数<strong>mode</strong>，其可选项如下：</p>
<table>
<thead>
<tr>
<th><strong>字符串</strong></th>
<th align="left"><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td align="left">以只读方式打开文件，该文件必须存在。</td>
</tr>
<tr>
<td>r+</td>
<td align="left">以读/写方式打开文件，该文件必须存在。</td>
</tr>
<tr>
<td>rb+</td>
<td align="left">以读/写方式打开一个二进制文件，只允许读/写数据。</td>
</tr>
<tr>
<td>rt+</td>
<td align="left">以读/写方式打开一个文本文件，允许读和写。</td>
</tr>
<tr>
<td>w</td>
<td align="left">打开只写文件，若文件存在则文件长度清为零，即该文件内容会消失；若文件不存在则创建该文件。</td>
</tr>
<tr>
<td>w+</td>
<td align="left">打开可读/写文件，若文件存在则文件长度清为零，即该文件内容会消失；若文件不存在则创建该文件。</td>
</tr>
<tr>
<td>a</td>
<td align="left">以附加的方式打开只写文件。若文件不存在，则会创建该文件；如果文件存在，则写入的数据会被加到文件尾后，即文件原先的内容会被保留（EOF 符保留）。</td>
</tr>
<tr>
<td>a+</td>
<td align="left">以附加方式打开可读/写的文件。若文件不存在，则会创建该文件，如果文件存在，则写入的数据会被加到文件尾后，即文件原先的内容会被保留（EOF符不保留）。</td>
</tr>
<tr>
<td>wb</td>
<td align="left">以只写方式打开或新建一个二进制文件，只允许写数据。</td>
</tr>
<tr>
<td>wb+</td>
<td align="left">以读/写方式打开或新建一个二进制文件，允许读和写。</td>
</tr>
<tr>
<td>wt+</td>
<td align="left">以读/写方式打开或新建一个文本文件，允许读和写。</td>
</tr>
<tr>
<td>at+</td>
<td align="left">以读/写方式打开一个文本文件，允许读或在文本末追加数据。</td>
</tr>
<tr>
<td>ab+</td>
<td align="left">以读/写方式打开一个二进制文件，允许读或在文件末追加数据。</td>
</tr>
</tbody></table>
<blockquote>
<p>From百度百科</p>
</blockquote>
<p>我最初选择的参数是<code>wb+</code>，会出现上一节所提到的文件大小改变的问题，而后来选择<code>rb+</code>则不会；</p>
<p>从表格上看，这二者的功能描述并无太大区别，其实表格内容省略了一些说明，因为<code>wb+</code>本身应当是<code>w+</code>的<em>二进制文件版</em>，所以其完整说明应该参照<code>w+</code>来补全，得到如下区别：</p>
<ul>
<li><code>wb+</code>无论文件是否存在都可以打开成功，<code>rb+</code>必须要文件存在时才能打开成功；</li>
<li>若文件存在，<code>wb+</code><strong>将文件长度清为零，重新写入数据</strong>，<code>rb+</code><strong>覆盖写入文件</strong>；</li>
</ul>
<p>现在可以知道，文件大小改变是因为每次打开文件后，原文件内容就被清除了，只剩下最近一次写入操作的内容；</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>关于<em>修改指定位置的文件内容</em>，需要搭配函数<code>fseek</code>一起使用，该函数的作用是调整文件指针的位置，函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseek</span><span class="params">(FILE *stream, <span class="keyword">long</span> offset, <span class="keyword">int</span> fromwhere)</span></span>;</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<ul>
<li>*<em>stream</em>：文件指针</li>
<li><em>offset</em>：相对于基址的偏移量，基址由后一个参数决定</li>
<li><em>fromwhere</em>：基址，有三种基础选项：<code>SEEK_SET</code>——文件开头，<code>SEEK_CUR</code>——文件指针当前指向位置，<code>CUR_END</code>——文件末尾</li>
</ul>
<p>写入操作应当使用<code>fwrite</code>而不是<code>fputs</code>/<code>fputc</code>，因为<code>fwrite</code>是<strong>以二进制格式向文件写入数据块</strong>，而<code>fputs</code>/<code>fputc</code>是将<strong>字符串/字符</strong>输入到文件，在对二进制文件进行操作时不应当使用；</p>
<h1 id="2-fscanf读取多行数据"><a href="#2-fscanf读取多行数据" class="headerlink" title="2.fscanf读取多行数据"></a>2.fscanf读取多行数据</h1><p>现有文本文件内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a 1 4 50</span><br><span class="line">b 2 3 100</span><br><span class="line">c 4 5 40</span><br></pre></td></tr></table></figure>

<p>每一行均为 “字符串 整型 整型 整型” 的格式，欲使用函数<code>fscanf</code>读取多行数据</p>
<h2 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h2><p>先了解<code>fscanf</code>的函数原型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fscanf</span><span class="params">(FILE * stream, <span class="keyword">const</span> <span class="keyword">char</span> * format, [argument...])</span></span>;</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<ul>
<li><em>stream</em>: 指向 FILE 对象的指针，该 FILE 对象标识了流；</li>
<li><em>format</em>:  字符串，包含了以下各项中的一个或多个：<em>空格字符、非空格字符</em> 和 <em>format 说明符</em>；</li>
</ul>
<p>使用方法与<code>scanf</code>几乎一致，只不过<code>fscanf</code>是用于读取<strong>文件</strong>内容的；</p>
<p>实现代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">readMultLines</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> int1;</span><br><span class="line">    <span class="keyword">int</span> int2;</span><br><span class="line">    <span class="keyword">int</span> int3;</span><br><span class="line">    FILE *fp = fopen(<span class="string">"filename.txt"</span>, <span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!feof(file)) &#123;</span><br><span class="line">        <span class="built_in">fscanf</span>(file, <span class="string">"%s %d %d %d\n"</span>, str, &amp;int1, &amp;int2, &amp;int3);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot访问上传资源的问题</title>
    <url>/2022/02/19/SpringBoot%E8%AE%BF%E9%97%AE%E4%B8%8A%E4%BC%A0%E8%B5%84%E6%BA%90%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>本篇分析SpringBoot项目访问上传资源需要重新启动项目的原因以及解决方法</p>
<a id="more"></a>

<h1 id="SpringBoot访问上传资源的问题"><a href="#SpringBoot访问上传资源的问题" class="headerlink" title="SpringBoot访问上传资源的问题"></a>SpringBoot访问上传资源的问题</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>项目需要上传图片到后端，因为项目不大就没做图片服务器，直接将上传的图片保存到项目目录下。这里我将图片文件保存在了存放静态资源的目录中，即<code>\src\main\resources\static\</code>。在访问上传资源的时候发现并不能访问到上传的资源，报错404，而查看目录发现图片文件又确实保存在里面了。</p>
<h2 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h2><p>服务器对资源文件实现了保护机制，本地服务器不能对外暴露真实的资源路径。<br>所以前端请求资源的时候并不是在<code>\src\main\resources\static\</code>目录下寻找对应文件，而是在项目编译后生成的target目录下寻找资源，一般静态资源在<code>\target\classes\static</code>中；<br>所以在文件上传完成后，如果没有重启项目把上传的资源编译到 target 文件夹里（这是对外暴露的），便无法访问</p>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>配置资源访问路径映射，新建 ResourceConfig.java ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        String path = <span class="keyword">new</span> FileSystemResource(<span class="string">""</span>).getFile().getAbsolutePath() + <span class="string">"\\webip\\src\\main\\resources\\static\\img\\"</span>;<span class="comment">// 这里的path是你保存资源的绝对路径</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//配置静态资源访问路径</span></span><br><span class="line">		registry.addResourceHandler(<span class="string">"/upload/**"</span>).addResourceLocations(<span class="string">"file:"</span>+path);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基本思路是<strong>实现 WebMvcConfigurer</strong>，重写 <code>addResourceHandlers(ResourceHandlerRegistry registry)</code>方法，<code>addResourceHandler（）</code>添加的是访问路径，即前端发送请求时的url，<code>addResourceLocations（）</code>添加的是映射后的真实路径。实际上就是配置一个拦截器， 如果访问路径是<code>addResourceHandler()</code>的参数中的路径，那么就映射到访问本地的<code>addResourceLocations()</code> 的参数的这个路径上，这样就可以让前端访问服务器的本地文件了。</p>
]]></content>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>Skewed-associative_Caches</title>
    <url>/2020/07/01/Skewed-associative-Caches/</url>
    <content><![CDATA[<p>参考几篇论文后总结得出的关于偏斜相联缓存的一些基础知识</p>
<a id="more"></a>
<h2 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h2><p>CPU 速度与主存速度的剪刀差导致主存成为性能瓶颈，为了缓和这一速度差而提出了缓存技术，而缓存技术的应用则带来了诸如缓存命中率、失效开销、硬件复杂度、替换策略等一系列问题；<br>偏斜相联 Cache 具有更高的的命中率和更低的硬件复杂度，如：二体偏斜相联 Cache (<em>two-banks skewed-associative cache</em>) 拥有相当于<strong>四路组相联 Cache 的命中率</strong>，而只拥有接近<strong>二路组相联 Cache 的硬件复杂度</strong></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>偏斜相联 Cache 的硬件组织方式与组相联 Cache 十分类似</p>
<h3 id="组相联-Cache-的硬件组织"><a href="#组相联-Cache-的硬件组织" class="headerlink" title="组相联 Cache 的硬件组织"></a>组相联 Cache 的硬件组织</h3><p>将 Cache 分为多个存储体(<em>Bank</em>)，内存行地址的基址 D 会被映射成 Cache 存储体的物理行地址 f(D)，此处 <strong>Cache 中所有存储体的行地址都相同</strong><br>即：访存地址 D 经过散列函数映射到<strong>不同存储体的同一行</strong><br>如下图：<br><img src="/2020/07/01/Skewed-associative-Caches/2way_set-asso.jpg" alt="2way"></p>
<h3 id="一点微小的改动"><a href="#一点微小的改动" class="headerlink" title="一点微小的改动"></a>一点微小的改动</h3><p>在上面组相联 Cache 的基础上，做一点微小的工作，就能得到*偏斜相联 Cache *：</p>
<ul>
<li>每个存储体使用<strong>不同的</strong>散列函数</li>
<li>使得访存地址 D 映射到<strong>不同存储体的不同行</strong><br>如下图：<br><img src="/2020/07/01/Skewed-associative-Caches/skewed-asso.jpg" alt="skewed-asso"><blockquote>
<p>可以看到，对于左边的存储体使用了函数 f<sub>1</sub> , 而对于右边的存储体则使用了另一个函数 f<sub>2</sub></p>
</blockquote>
</li>
</ul>
<p>由于散列函数由硬件直接实现，所以使用不同的散列函数必然会导致<strong>硬件复杂度的增加</strong>，但是这种复杂度的增加是十分微小的（在实现时，会选择用尽量少的门来实现散列函数），同时它又会带来相当可观的<strong>命中率的提升</strong>，进而带来处理器整体性能的提升</p>
<h3 id="偏斜函数的选择"><a href="#偏斜函数的选择" class="headerlink" title="偏斜函数的选择"></a>偏斜函数的选择</h3><p>需要考虑如下因素</p>
<h4 id="均匀度"><a href="#均匀度" class="headerlink" title="均匀度"></a>均匀度</h4><p>对于缓存中的的每行,应当有相同数量的主存行映射到该行</p>
<h4 id="存储体间的分散"><a href="#存储体间的分散" class="headerlink" title="存储体间的分散"></a>存储体间的分散</h4><p>这是偏斜相联 Cache 提高性能的关键原理之一<br>普通组相联 Cache 当两行数据被映射到 Cache 的同一行时，这些数据在所有存储体（所有组）中都是冲突的<br>为了避免这种情况，偏斜相联 Cache 的映射函数应当通过打散这些数据来避免这种情况的发生，即映射函数应该满足如下要求：当几行数据被映射到 Cache 的<em>存储体 i</em> 中的同一行时，它们有<strong>极低的概率</strong>被映射到<em>存储体 j</em> 的同一行而产生冲突，如下图<br><img src="/2020/07/01/Skewed-associative-Caches/inter-bank_dispersion.jpg" alt="inter-bank"></p>
<h4 id="存储体内的分散"><a href="#存储体内的分散" class="headerlink" title="存储体内的分散"></a>存储体内的分散</h4><p>这是考虑到程序的<strong>空间局部性</strong>而提出的要求<br>映射函数应该满足如下要求：避免将两个在主存中距离很近的行映射到 Cache 中的同一行</p>
<h4 id="简单的硬件实现"><a href="#简单的硬件实现" class="headerlink" title="简单的硬件实现"></a>简单的硬件实现</h4><p>为了尽量减小实现多个映射函数对整体性能的影响，应当选择硬件实现简单（门延迟尽可能少）的映射函数</p>
<h3 id="替换策略的选择"><a href="#替换策略的选择" class="headerlink" title="替换策略的选择"></a>替换策略的选择</h3><h4 id="LRU-Least-Recently-Used"><a href="#LRU-Least-Recently-Used" class="headerlink" title="LRU(Least Recently Used)"></a>LRU(Least Recently Used)</h4><p>虽然 LRU 算法通常被认为是最有效，同时也是被广泛使用的策略，但是对于偏斜相联 Cache 来说，<strong>难以找到在偏斜相联 Cache 中对 LRU 的简单硬件实现</strong>，故偏斜相联 Cache 一般<strong>不采用</strong> LRU 策略</p>
<h4 id="NRUNRW-Not-Recently-Used-Not-Recently-Written"><a href="#NRUNRW-Not-Recently-Used-Not-Recently-Written" class="headerlink" title="NRUNRW(Not Recently Used Not Recently Written)"></a>NRUNRW(Not Recently Used Not Recently Written)</h4><p>实质上是一种“伪 LRU 算法”<br>工作原理：</p>
<ul>
<li>Cache 中每行附加 1 bit 的 RU(Recently Used) 位，<strong>当该行被访问时，RU 置1</strong></li>
<li>周期性清零 RU 位</li>
</ul>
<p>当需要进行替换时，按下列顺序进行规则选择：</p>
<ol>
<li>随机选择 RU 位为零的行</li>
<li>随机选择 RU 位为 1 ，但装入 Cache 后<strong>未被修改</strong>的行</li>
<li>随机选择 RU 位为 1 ，且被修改过的行<blockquote>
<ul>
<li>所谓“按顺序”，即当按照规则 1 无法找出符合条件的行时，则寻找符合规则 2 的行，以此类推</li>
<li>对于指令缓存(instruction cache)来说，不存在规则 3</li>
</ul>
</blockquote>
</li>
</ol>
]]></content>
      <tags>
        <tag>Computer Architecture</tag>
      </tags>
  </entry>
  <entry>
    <title>node.js学习_2</title>
    <url>/2020/02/26/node-js%E5%AD%A6%E4%B9%A0-2/</url>
    <content><![CDATA[<p>Node.js 学习之二：代码的组织和部署<br>本文参考：<a href="http://nqdeng.github.io/7-days-nodejs" target="_blank" rel="noopener">http://nqdeng.github.io/7-days-nodejs</a></p>
<a id="more"></a>

<h1 id="代码的组织和部署"><a href="#代码的组织和部署" class="headerlink" title="代码的组织和部署"></a>代码的组织和部署</h1><h2 id="模块路径解析规则"><a href="#模块路径解析规则" class="headerlink" title="模块路径解析规则"></a>模块路径解析规则</h2><h3 id="绝对路径和相对路径的问题"><a href="#绝对路径和相对路径的问题" class="headerlink" title="绝对路径和相对路径的问题"></a>绝对路径和相对路径的问题</h3><p>在之前的学习中，我们已知<code>require</code>函数同时支持<em>绝对路径</em> 和<em>相对路径</em> （见<a href="https://table-the-cat.github.io/2020/02/24/node-js%E5%AD%A6%E4%B9%A0-1/"> node.js 学习_1 </a>），但这种引用方式存在一定的弊端：当某个模块A的文件的存放位置发生改变时，所有使用了模块A的模块代码都需要修改</p>
<h3 id="第三种形式"><a href="#第三种形式" class="headerlink" title="第三种形式"></a>第三种形式</h3><p>为了改善上述问题，<code>require</code>函数支持了另一种形式的路径，写法类似于<code>foo/bar</code>，并按照以下规则解析路径，直到找到模块位置</p>
<ol>
<li><p>内置模块<br> 若传递给<code>require</code>的是 Node.js 内置模块的名称，则不做路径解析，直接返回内部模块的导出对象，如<code>require(&#39;fs&#39;)</code></p>
<blockquote>
<p>关于内置模块，可以查阅<a href="https://nodejs.org/zh-cn/docs/" target="_blank" rel="noopener">官方文档</a><br>比如上文提到的 fs 模块，其官方文档<a href="https://nodejs.org/dist/latest-v11.x/docs/api/fs.html" target="_blank" rel="noopener">在这里</a></p>
</blockquote>
</li>
<li><p>node_modules 目录<br> <code>node_modules</code> 目录专门用于存放模块<br> 若某个模块A的绝对路径是<code>/home/user/hello.js</code>，则在模块A中使用<code>require(&#39;foo/bar&#39;)</code>方式加载模块时，Node.js 依次在以下路径中寻找目标文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;home&#x2F;user&#x2F;node_modules&#x2F;foo&#x2F;bar</span><br><span class="line">&#x2F;home&#x2F;node_modules&#x2F;foo&#x2F;bar</span><br><span class="line">&#x2F;node_modules&#x2F;foo&#x2F;bar</span><br></pre></td></tr></table></figure>
</li>
<li><p>NODE_PATH 环境变量<br> Node.js 允许通过<code>NODE_PATH</code>环境变量来指定额外的模块搜索路径</p>
<blockquote>
<p>NODE_PATH环境变量可以包含多个路径，路径之间在Linux下使用<code>:</code>分隔，在Windows下使用<code>;</code>分隔</p>
</blockquote>
<p> 如，若定义<code>NODE_PATH</code>环境变量如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;home&#x2F;user&#x2F;lib:&#x2F;home&#x2F;lib</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>​      则当用<code>require(&#39;foo/bar&#39;)</code>方式加载模块时，Node.js 依次在以下路径中寻找目标文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;home&#x2F;user&#x2F;lib&#x2F;foo&#x2F;bar</span><br><span class="line">&#x2F;home&#x2F;lib&#x2F;foo&#x2F;bar</span><br></pre></td></tr></table></figure>
<p><span style="color:red">注意！</span>只有在 Node.js <strong>没有</strong>在第二步的路径中（即node_modules的那三个路径）找到目标模块时，才会在 <code>NODE_PATH</code>保存的路径中寻找</p>
<h2 id="包-package"><a href="#包-package" class="headerlink" title="包(package)"></a>包(package)</h2><p>为了便于管理和使用，我们将由多个<em>子模块</em> 组成的模块称为<strong>包</strong>，并将所有子模块保存在同一个目录</p>
<h3 id="入口模块"><a href="#入口模块" class="headerlink" title="入口模块"></a>入口模块</h3><p>在一个包中，需要指定其中的一个子模块为<strong>入口模块</strong>，该入口模块的导出对象作为整个包的导出对象</p>
<p>例如有以下目录结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- &#x2F;home&#x2F;user&#x2F;lib&#x2F;</span><br><span class="line">    - cat&#x2F;</span><br><span class="line">        head.js</span><br><span class="line">        body.js</span><br><span class="line">        main.js</span><br></pre></td></tr></table></figure>

<p>其中<code>cat</code>目录定义了一个包，其中包含了3个子模块。<code>main.js</code>作为入口模块，其内容如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> head = <span class="built_in">require</span>(<span class="string">'./head'</span>);</span><br><span class="line"><span class="keyword">var</span> body = <span class="built_in">require</span>(<span class="string">'./body'</span>);</span><br><span class="line"></span><br><span class="line">exports.create = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name: name,</span><br><span class="line">        head: head.create(),</span><br><span class="line">        body: body.create()</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="包的使用"><a href="#包的使用" class="headerlink" title="包的使用"></a>包的使用</h3><p>在其它模块里使用包的时候，需要加载包的<em>入口模块</em>。接上例，使用<code>require(&#39;/home/user/lib/cat/main&#39;)</code>能达到目的，但是入口模块名称出现在路径里看上去不是个好主意。因此我们需要做点额外的工作，让包使用起来更像是单个模块</p>
<h3 id="index-js"><a href="#index-js" class="headerlink" title="index.js"></a>index.js</h3><p>当我们将文件命名为<code>index.js</code>时，加载模块时可以使用<em>模块所在目录的路径</em> 代替<em>模块文件路径</em> 。所以，我们可以将包的入口模块命名为<code>index.js</code>，在上例中即为将<code>main.js</code>改为<code>index.js</code>，重命名后，以下两条语句等价</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cat = <span class="built_in">require</span>(<span class="string">'/home/user/lib/cat'</span>);</span><br><span class="line"><span class="keyword">var</span> cat = <span class="built_in">require</span>(<span class="string">'/home/user/lib/cat/index'</span>);</span><br></pre></td></tr></table></figure>

<p>这样，引用包时可以只将包的目录路径传给require函数，使用起来更像是单个模块</p>
<h3 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h3><h4 id="package-json-是什么"><a href="#package-json-是什么" class="headerlink" title="package.json 是什么"></a>package.json 是什么</h4><p>package.json 是一个项目或模块（包也可以看作是一个模块）的<em>描述文件</em>，该文件包含诸如项目名称、版本、依赖等</p>
<h4 id="文件创建"><a href="#文件创建" class="headerlink" title="文件创建"></a>文件创建</h4><ul>
<li><p>手动创建<br>  在项目根目录新建一个 package.json 文件，输入相关内容</p>
</li>
<li><p>自动创建<br>  在项目根目录下输入命令行指令 <code>npm init</code> ，交互式地生成一份最简单的 package.json 文件</p>
</li>
</ul>
<h4 id="文件概览"><a href="#文件概览" class="headerlink" title="文件概览"></a>文件概览</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"exchange"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"0.1.0"</span>,</span><br><span class="line">  <span class="attr">"author"</span>: <span class="string">"zhangsan &lt;zhangsan@163.com&gt;"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">"第一个node.js程序"</span>,</span><br><span class="line">  <span class="attr">"keywords"</span>:[<span class="string">"node.js"</span>,<span class="string">"javascript"</span>],</span><br><span class="line">  <span class="attr">"private"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"bugs"</span>:&#123;<span class="attr">"url"</span>:<span class="string">"http://path/to/bug"</span>,<span class="attr">"email"</span>:<span class="string">"bug@example.com"</span>&#125;,</span><br><span class="line">  <span class="attr">"contributors"</span>:[&#123;<span class="attr">"name"</span>:<span class="string">"李四"</span>,<span class="attr">"email"</span>:<span class="string">"lisi@example.com"</span>&#125;],</span><br><span class="line">  <span class="attr">"repository"</span>: &#123;</span><br><span class="line">		<span class="attr">"type"</span>: <span class="string">"git"</span>,</span><br><span class="line">		<span class="attr">"url"</span>: <span class="string">"https://path/to/url"</span></span><br><span class="line">	&#125;,</span><br><span class="line">  <span class="attr">"homepage"</span>: <span class="string">"http://necolas.github.io/normalize.css"</span>,</span><br><span class="line">  <span class="attr">"license"</span>:<span class="string">"MIT"</span>,</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"react"</span>: <span class="string">"^16.8.6"</span>,</span><br><span class="line">    <span class="attr">"react-dom"</span>: <span class="string">"^16.8.6"</span>,</span><br><span class="line">    <span class="attr">"react-router-dom"</span>: <span class="string">"^5.0.1"</span>,</span><br><span class="line">    <span class="attr">"react-scripts"</span>: <span class="string">"3.0.1"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"browserify"</span>: <span class="string">"~13.0.0"</span>,</span><br><span class="line">    <span class="attr">"karma-browserify"</span>: <span class="string">"~5.0.1"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"start"</span>: <span class="string">"react-scripts start"</span>,</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"react-scripts build"</span>,</span><br><span class="line">    <span class="attr">"test"</span>: <span class="string">"react-scripts test"</span>,</span><br><span class="line">    <span class="attr">"eject"</span>: <span class="string">"react-scripts eject"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"bin"</span>: &#123;</span><br><span class="line">  <span class="attr">"webpack"</span>: <span class="string">"./bin/webpack.js"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"lib/webpack.js"</span>,</span><br><span class="line">  <span class="attr">"module"</span>: <span class="string">"es/index.js"</span>,</span><br><span class="line">  <span class="attr">"eslintConfig"</span>: &#123;</span><br><span class="line">    <span class="attr">"extends"</span>: <span class="string">"react-app"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"engines"</span> : &#123; </span><br><span class="line">    <span class="attr">"node"</span> : <span class="string">"&gt;=0.10.3 &lt;0.12"</span> </span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"browserslist"</span>: &#123;</span><br><span class="line">    <span class="attr">"production"</span>: [</span><br><span class="line">      <span class="string">"&gt;0.2%"</span>,</span><br><span class="line">      <span class="string">"not dead"</span>,</span><br><span class="line">      <span class="string">"not op_mini all"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"development"</span>: [</span><br><span class="line">      <span class="string">"last 1 chrome version"</span>,</span><br><span class="line">      <span class="string">"last 1 firefox version"</span>,</span><br><span class="line">      <span class="string">"last 1 safari version"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"style"</span>: [</span><br><span class="line">  <span class="string">"./node_modules/tipso/src/tipso.css"</span></span><br><span class="line">],</span><br><span class="line">  <span class="attr">"files"</span>: [</span><br><span class="line">    <span class="string">"lib/"</span>,</span><br><span class="line">    <span class="string">"bin/"</span>,</span><br><span class="line">    <span class="string">"buildin/"</span>,</span><br><span class="line">    <span class="string">"declarations/"</span>,</span><br><span class="line">    <span class="string">"hot/"</span>,</span><br><span class="line">    <span class="string">"web_modules/"</span>,</span><br><span class="line">    <span class="string">"schemas/"</span>,</span><br><span class="line">    <span class="string">"SECURITY.md"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h4><p><strong>name</strong>：项目/模块名称，长度必须小于等于214个字符，不能以”.”(点)或者”_”(下划线)开头，不能包含大写字母；<br><strong>version</strong>：项目版本；<br><strong>author</strong>：项目开发者，它的值是你在 <a href="https://npmjs.org" target="_blank" rel="noopener">https://npmjs.org</a> 网站的有效账户名；<br><strong>description</strong>：项目描述，是一个字符串。它可以帮助人们在使用<code>npm search</code>时找到这个包；<br><strong>keywords</strong>：项目关键字，是一个字符串数组。它可以帮助人们在使用<code>npm search</code>时找到这个包；<br><strong>private</strong>：是否私有，设置为 <code>true</code>时，npm 拒绝发布；<br><strong>license</strong>：软件授权条款，让用户知道他们的使用权利和限制；<br><strong>bugs</strong>：bug 提交地址；<br><strong>contributors</strong>：项目贡献者 ；<br><strong>repository</strong>：项目仓库地址；<br><strong>homepage</strong>：项目包的官网 URL；<br><strong>dependencies</strong>：生产环境下，项目运行所需依赖；<br><strong>devDependencies</strong>：开发环境下，项目所需依赖；<br><strong>scripts</strong>：执行 npm 脚本命令简写，比如 <code>“start”: “react-scripts start”</code>, 执行 <code>npm start</code> 就是运行 “react-scripts start”；<br><strong>bin</strong>：内部命令对应的可执行文件的路径；<br><strong>main</strong>：项目默认执行文件，比如 <code>require(‘webpack’)</code>；就会默认加载 lib 目录下的 <code>webpack.js</code> 文件，如果没有设置，则默认加载项目根目录下的<code>index.js</code>文件；<br><strong>module</strong>：是以 ES Module(也就是 ES6)模块化方式进行加载，因为早期没有 ES6 模块化方案时，都是遵循 CommonJS 规范，而 CommonJS 规范的包是以 main 的方式表示入口文件的，为了区分就新增了 module 方式，但是 ES6 模块化方案效率更高，所以会优先查看是否有 module 字段，没有才使用 main 字段；<br><strong>eslintConfig</strong>：EsLint 检查文件配置，自动读取验证；<br><strong>engines</strong>：项目运行的平台；<br><strong>browserslist</strong>：供浏览器使用的版本列表；<br><strong>style</strong>：供浏览器使用时，样式文件所在的位置；样式文件打包工具parcelify，通过它知道样式文件的打包位置；<br><strong>files</strong>：被项目包含的文件名数组；</p>
<h4 id="回到开始的问题"><a href="#回到开始的问题" class="headerlink" title="回到开始的问题"></a>回到开始的问题</h4><p>绕了一圈之后，我们对 package.json 已经有了一定了解，那么回到开始的问题：如何使用 package.json 实现使用<code>require(&#39;/home/user/lib/cat&#39;)</code>的方式加载模块？<br>方法很简单，设置参数<code>main</code>的值即可；<br>回到上面<code>cat</code>包的例子，我们将模块重构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- &#x2F;home&#x2F;user&#x2F;lib&#x2F;</span><br><span class="line">    - cat&#x2F;</span><br><span class="line">        + doc&#x2F;</span><br><span class="line">        - lib&#x2F;</span><br><span class="line">            head.js</span><br><span class="line">            body.js</span><br><span class="line">            main.js</span><br><span class="line">        + tests&#x2F;</span><br><span class="line">        package.json</span><br></pre></td></tr></table></figure>

<p>其中<code>package.json</code>中参数<code>main</code>赋值如下:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"main"</span>: <span class="string">"./lib/main.js"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如此一来，就同样可以使用<code>require(&#39;/home/user/lib/cat&#39;)</code>的方式加载模块。NodeJS会根据包目录下的<code>package.json</code>找到入口模块所在位置</p>
<h2 id="命令行程序"><a href="#命令行程序" class="headerlink" title="命令行程序"></a>命令行程序</h2><blockquote>
<p>使用NodeJS编写的东西，要么是一个包，要么是一个命令行程序，而<strong>前者最终也会用于开发后者</strong>。因此我们在部署代码时需要一些技巧，让用户觉得自己是在使用一个命令行程序。</p>
</blockquote>
<p>例如我们有一个程序在<code>/home/user/bin/node-echo.js</code>，现在我们要运行它，则应当输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node &#x2F;home&#x2F;user&#x2F;bin&#x2F;node-echo.js Hello World</span><br><span class="line">&#x2F;&#x2F;Hello World 为输入的参数</span><br></pre></td></tr></table></figure>
<p>但是我们期望像使用命令行程序一样使用它，即我们期望下面的输入方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node-echo Hello World</span><br></pre></td></tr></table></figure>

<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p>在Linux系统下，我们可以把JS文件当作<em>shell脚本</em> 来运行，从而达到上述目的：</p>
<ol>
<li><p>在shell脚本中，可以通过<code>#!</code>注释来指定当前脚本使用的解析器。所以我们首先在<code>node-echo.js</code>文件顶部增加以下一行注释，表明当前脚本使用NodeJS解析。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env node</span><br></pre></td></tr></table></figure>
<blockquote>
<p>NodeJS会忽略掉位于JS模块首行的<code>#!</code>注释，不必担心这行注释是非法语句。</p>
</blockquote>
</li>
<li><p>然后，我们使用以下命令赋予<code>node-echo.js</code>文件执行权限。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ chmod +x &#x2F;home&#x2F;user&#x2F;bin&#x2F;node-echo.js</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后，我们在PATH环境变量中指定的某个目录下，例如在<code>/usr/local/bin</code>下边创建一个软链文件，文件名与我们希望使用的终端命令同名，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo ln -s &#x2F;home&#x2F;user&#x2F;bin&#x2F;node-echo.js &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node-echo</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>这样处理后，我们就可以在任何目录下使用<code>node-echo</code>命令了</p>
<h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>在Windows系统下，需要用<code>.cmd</code>文件实现<br>假设<code>node-echo.js</code>存放在<code>C:\Users\user\bin</code>目录，并且该目录已经添加到PATH环境变量中。然后在该目录下新建一个文件，命名为<code>node-echo.cmd</code>，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@node &quot;C:\Users\user\bin\node-echo.js&quot; %*</span><br></pre></td></tr></table></figure>

<p>这样，便可以直接使用<code>node-echo</code>命令了</p>
<h2 id="工程目录"><a href="#工程目录" class="headerlink" title="工程目录"></a>工程目录</h2><p>现在，我们可以尝试完整地规划一个工程目录。<br>以编写一个<em>命令行程序</em> 为例，标准的工程目录大致如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- &#x2F;home&#x2F;user&#x2F;workspace&#x2F;node-echo&#x2F;   # 工程目录</span><br><span class="line">    - bin&#x2F;                          # 存放命令行相关代码</span><br><span class="line">        node-echo</span><br><span class="line">    + doc&#x2F;                          # 存放文档</span><br><span class="line">    - lib&#x2F;                          # 存放API相关代码</span><br><span class="line">        echo.js</span><br><span class="line">    - node_modules&#x2F;                 # 存放三方包</span><br><span class="line">        + argv&#x2F;</span><br><span class="line">    + tests&#x2F;                        # 存放测试用例</span><br><span class="line">    package.json                    # 元数据文件</span><br><span class="line">    README.md                       # 说明文件</span><br></pre></td></tr></table></figure>

<p>其中部分文件内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* bin&#x2F;node-echo *&#x2F;</span><br><span class="line">var argv &#x3D; require(&#39;argv&#39;),</span><br><span class="line">    echo &#x3D; require(&#39;..&#x2F;lib&#x2F;echo&#39;);</span><br><span class="line">console.log(echo(argv.join(&#39; &#39;)));</span><br><span class="line"></span><br><span class="line">&#x2F;* lib&#x2F;echo.js *&#x2F;</span><br><span class="line">module.exports &#x3D; function (message) &#123;</span><br><span class="line">    return message;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;* package.json *&#x2F;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;node-echo&quot;,</span><br><span class="line">    &quot;main&quot;: &quot;.&#x2F;lib&#x2F;echo.js&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上例子中分类存放了不同类型的文件，并通过<code>node_moudles</code>目录直接使用三方包名加载模块。此外，定义了<code>package.json</code>之后，<code>node-echo</code>目录也可被当作一个包来使用</p>
<h2 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h2><h3 id="npm是什么"><a href="#npm是什么" class="headerlink" title="npm是什么"></a>npm是什么</h3><blockquote>
<p>npm 为你和你的团队打开了连接整个 JavaScript 天才世界的一扇大门。它是世界上最大的软件注册表，每星期大约有 30 亿次的下载量，包含超过 600000 个 包（package） （即，代码模块）。来自各大洲的开源软件开发者使用 npm 互相分享和借鉴。包的结构使您能够轻松跟踪依赖项和版本。<br>——From <a href="https://www.npmjs.cn/getting-started/what-is-npm/" target="_blank" rel="noopener">https://www.npmjs.cn/getting-started/what-is-npm/</a></p>
</blockquote>
<p>npm即<em>node package manager</em>，是随同Node.js一起安装的包管理工具，常见使用场景如下：</p>
<ul>
<li>允许用户从npm服务器下载<em>三方包</em>到本地使用</li>
<li>允许用户从npm服务器下载安装他人编写的<em>命令行程序</em>到本地使用</li>
<li>允许用户将自己编写的包或命令行程序上传至npm服务器</li>
</ul>
<h3 id="下载三方包"><a href="#下载三方包" class="headerlink" title="下载三方包"></a>下载三方包</h3><p>通过如下命令来下载三方包：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install packageName</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在 <a href="https://www.npmjs.com/" target="_blank" rel="noopener">npmjs.com</a> 中提供了搜索框，用于<strong>根据包名</strong>搜索有哪些包是可用的</p>
</blockquote>
<p>例如我们可用<code>npm install argv</code>来下载<code>argv</code>包，下载完成后该包便被放在工程目录下的<code>node_modules</code>目录中，因此可用直接通过包名使用</p>
<h4 id="指定版本"><a href="#指定版本" class="headerlink" title="指定版本"></a>指定版本</h4><p>上述指令默认下载三方包的最新版本，当我们需要指定下载版本时，可以使用<code>@&lt;version&gt;</code>来指定版本，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install argv@0.0.1</span><br></pre></td></tr></table></figure>

<h4 id="配合package-json"><a href="#配合package-json" class="headerlink" title="配合package.json"></a>配合package.json</h4><p>若一个工程需要较多的三方包，一条一条地输入指令下载显然是低效且无意义的，我们可以在<code>package.json</code>中的<code>dependencies</code>字段上声明所需的三方包依赖，然后直接使用<code>npm install</code>指令实现<strong>批量下载</strong></p>
<p>这样做还有一个好处：当你将自己的包发布到npm服务器上供他人使用时，别人下载这个包的时候，npm会根据包中声明的三方包依赖自动下载进一步依赖的三方包。如此用户在使用包时，可以<strong>只关心自己直接使用的三方包，不需要自己去解决所有包的依赖关系</strong></p>
<h3 id="安装命令行程序"><a href="#安装命令行程序" class="headerlink" title="安装命令行程序"></a>安装命令行程序</h3><p>与三方包的下载方式类似。例如上例中的<code>node-echo</code>提供了命令行使用方式，只要<code>node-echo</code>自己配置好了相关的<code>package.json</code>字段，对于用户而言，只需要使用以下命令安装程序。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install node-echo -g</span><br></pre></td></tr></table></figure>

<p>参数<code>-g</code>表示全局安装，因此<code>node-echo</code>会默认安装到以下位置，并且NPM会自动创建好Linux系统下需要的软链文件或Windows系统下需要的<code>.cmd</code>文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- &#x2F;usr&#x2F;local&#x2F;               # Linux系统下</span><br><span class="line">    - lib&#x2F;node_modules&#x2F;</span><br><span class="line">        + node-echo&#x2F;</span><br><span class="line">        ...</span><br><span class="line">    - bin&#x2F;</span><br><span class="line">        node-echo</span><br><span class="line">        ...</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">- %APPDATA%\npm\            # Windows系统下</span><br><span class="line">    - node_modules\</span><br><span class="line">        + node-echo\</span><br><span class="line">        ...</span><br><span class="line">    node-echo.cmd</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<h3 id="发布代码"><a href="#发布代码" class="headerlink" title="发布代码"></a>发布代码</h3><p>发布代码指令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm publish</span><br></pre></td></tr></table></figure>

<p>第一次使用npm发布代码时需要<strong>注册账号</strong>，在终端下输入指令<code>npm adduser</code>，随后按照提示进行注册即可。账号注册成功后，编辑<code>package.json</code>的内容，填充必要字段，必要字段如下：</p>
<ul>
<li>name：包名，在npm服务器上要<strong>保持唯一</strong></li>
<li>version：当前版本号</li>
<li>dependencies：三方包依赖，需要指定<strong>包名</strong>和<strong>版本号</strong></li>
<li>main：入口模块位置</li>
<li>bin：命令行程序名和主模块位置</li>
</ul>
<p>之后，需要在<code>package.json</code><strong>所在目录下</strong>执行<code>npm publish</code>指令发布代码</p>
<h3 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h3><p>npm使用<em>语义版本号</em> 管理代码</p>
<p>语义版本号结构为<code>X.Y.Z</code>，分为三位，分别代表<strong>主版本号</strong>、<strong>次版本号</strong>和<strong>补丁号</strong>，在代码变更时，应当按照以下原则更新版本：</p>
<ul>
<li>若只是<strong>修复bug</strong>，则更新Z位</li>
<li>若<strong>增加了新功能</strong>，但是<strong>向下兼容</strong>，则更新Y位</li>
<li>若有大变动且<strong>向下不兼容</strong>，则更新X位</li>
</ul>
<p>版本号有了这个保证后，在申明三方包依赖时，除了可依赖于一个固定版本号外，还可依赖于某个范围的版本号。例如<code>&quot;argv&quot;: &quot;0.0.x&quot;</code>表示依赖于<code>0.0.x</code>系列的最新版<code>argv</code>。NPM支持的所有版本号范围指定方式可以查看<a href="https://npmjs.org/doc/files/package.json.html#dependencies" target="_blank" rel="noopener">官方文档</a>。</p>
<h3 id="npm常用操作"><a href="#npm常用操作" class="headerlink" title="npm常用操作"></a>npm常用操作</h3><ul>
<li>使用<code>npm help</code>查看所有命令。</li>
<li>使用<code>npm help &lt;command&gt;</code>可查看某条命令的详细帮助，例如<code>npm help install</code>。</li>
<li>在<code>package.json</code>所在目录下使用<code>npm install . -g</code>可先在本地安装当前命令行程序，可用于发布前的本地测试。</li>
<li>使用<code>npm update</code>可以把当前目录下<code>node_modules</code>子目录里边的对应模块更新至最新版本。</li>
<li>使用<code>npm update  -g</code>可以把全局安装的对应命令行程序更新至最新版。</li>
<li>使用<code>npm cache clear</code>可以清空NPM本地缓存，用于对付使用相同版本号发布新版本代码的人。</li>
<li>使用<code>npm unpublish &lt;package&gt;@&lt;version&gt;</code>可以撤销发布自己发布过的某个版本代码。</li>
</ul>
<p>关于npm的更多功能，可以参考<a href="https://docs.npmjs.com/" target="_blank" rel="noopener">官方文档</a></p>
]]></content>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>node.js学习_1</title>
    <url>/2020/02/24/node-js%E5%AD%A6%E4%B9%A0-1/</url>
    <content><![CDATA[<p>node.js 学习的第一篇，主要介绍node.js的一些基本概念</p>
<a id="more"></a>

<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="Node-js-是什么"><a href="#Node-js-是什么" class="headerlink" title="Node.js 是什么"></a>Node.js 是什么</h2><blockquote>
<p>Node.js 是一个基于 Chrome V8  引擎的 Javascript 运行环境</p>
</blockquote>
<h2 id="Node-js-能做什么"><a href="#Node-js-能做什么" class="headerlink" title="Node.js 能做什么"></a>Node.js 能做什么</h2><p>简单来说，Node.js 能让 Javascript 代码在服务端运行</p>
<p>Javascript 是<strong>脚本语言</strong>，脚本语言的运行需要<strong>解析器</strong>，对于在浏览器端运行的 JS ，浏览器充当了解析器，而如果需要独立运行 JS ，则需要 Node.js 作为解析器。</p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul>
<li>单线程</li>
<li>异步 I/O</li>
<li>事件驱动<blockquote>
<p>以上特性会在后续文章中详细介绍</p>
</blockquote>
</li>
</ul>
<h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>在Node环境中，一个.js文件久称为一个模块<em>(module)</em>，文件路径就是模块名</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li>提高代码的可维护性</li>
<li>提高开发效率</li>
<li>避免函数名和变量名冲突<blockquote>
<p>相同名字的函数和变量完全可以分别存在不同的模块中</p>
</blockquote>
</li>
</ul>
<hr>
<p>在编写每个模块时，都有<code>require</code>, <code>exports</code>, <code>module</code>三个预先定义好的变量可供使用</p>
<h2 id="require"><a href="#require" class="headerlink" title="require"></a>require</h2><p><code>require</code>函数用于在当前模块中<strong>加载</strong>和<strong>使用</strong>别的模块，传入一个模块名，返回一个模块导出对象。</p>
<blockquote>
<p>模块名可以使用<em>相对路径<em>，也可以使用</em>绝对路径</em><br>模块名中的 <code>.js</code>扩展名可以省略</p>
</blockquote>
<p>如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo1 = <span class="built_in">require</span>(<span class="string">'./foo'</span>);</span><br><span class="line"><span class="keyword">var</span> foo2 = <span class="built_in">require</span>(<span class="string">'./foo.js'</span>);</span><br><span class="line"><span class="keyword">var</span> foo3 = <span class="built_in">require</span>(<span class="string">'/home/user/foo'</span>);</span><br><span class="line"><span class="keyword">var</span> foo4 = <span class="built_in">require</span>(<span class="string">'/home/user/foo.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// foo1至foo4中保存的是同一个模块的导出对象</span></span><br></pre></td></tr></table></figure>

<p><strong>另</strong>，<code>require</code>还可以用于加载和使用<em>JSON文件</em></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = <span class="built_in">require</span>(<span class="string">'./data.json'</span>);</span><br></pre></td></tr></table></figure>

<h2 id="exports"><a href="#exports" class="headerlink" title="exports"></a>exports</h2><p><code>exports</code>对象是当前模块的<strong>导出对象</strong>，用于导出模块的公有方法和属性。<br>别的模块通过<code>require</code>函数引用当前模块时得到的就是<strong>当前模块的<code>export</code>对象</strong><br>如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">exports.hello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'hello world!'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//以上代码导出了一个公有方法，即在别的模块调用require函数使用该模块时，可以使用hello方法</span></span><br></pre></td></tr></table></figure>

<h2 id="module"><a href="#module" class="headerlink" title="module"></a>module</h2><p>通过<code>module</code>对象可以访问当前模块的一些相关信息，但最多的用途是<strong>替换当前模块的导出对象</strong>。<br>例如模块导出对象默认是一个普通对象，如果想改成一个函数的话，可以使用以下方式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello World!'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//模块默认导出对象被替换成一个函数</span></span><br></pre></td></tr></table></figure>

<h2 id="模块初始化"><a href="#模块初始化" class="headerlink" title="模块初始化"></a>模块初始化</h2><p>一个模块中的 JS 代码仅在模块第一次被使用时执行一次，并在执行过程中初始化模块的导出对象；导出对象被<strong>缓存</strong>后可以重复利用</p>
<p><strong>所有模块在执行过程中只初始化一次</strong></p>
<h2 id="主模块"><a href="#主模块" class="headerlink" title="主模块"></a>主模块</h2><p>通过命令行参数传递给 Node.js 以启动程序的模块被称为主模块，主模块负责<strong>调度组成整个程序的其它模块完成工作</strong></p>
<p><strong>主模块是程序的入口</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ node main.js</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通过上述命令启动时，<code>main.js</code>就是主模块</p>
</blockquote>
<h2 id="完整示例"><a href="#完整示例" class="headerlink" title="完整示例"></a>完整示例</h2><blockquote>
<p>该示例引用自 <a href="http://nqdeng.github.io/7-days-nodejs/#1.5.6" target="_blank" rel="noopener"> 7-days-nodejs </a></p>
</blockquote>
<p>例如有以下目录。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- &#x2F;home&#x2F;user&#x2F;hello&#x2F;</span><br><span class="line">    - util&#x2F;</span><br><span class="line">        counter.js</span><br><span class="line">    main.js</span><br></pre></td></tr></table></figure>

<p>其中<code>counter.js</code>内容如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ++i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.count = count;</span><br></pre></td></tr></table></figure>

<p>该模块内部定义了一个私有变量<code>i</code>，并在<code>exports</code>对象导出了一个公有方法<code>count</code>。</p>
<p>主模块<code>main.js</code>内容如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> counter1 = <span class="built_in">require</span>(<span class="string">'./util/counter'</span>);</span><br><span class="line"><span class="keyword">var</span> counter2 = <span class="built_in">require</span>(<span class="string">'./util/counter'</span>);<span class="comment">//若此处被重新初始化，则counter2.count()应该返回1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(counter1.count());</span><br><span class="line"><span class="built_in">console</span>.log(counter2.count());</span><br><span class="line"><span class="built_in">console</span>.log(counter2.count());</span><br></pre></td></tr></table></figure>

<p>运行该程序的结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ node main.js</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>counter.js</code>并没有因为被require了两次而初始化两次。</p>
<h2 id="二进制模块"><a href="#二进制模块" class="headerlink" title="二进制模块"></a>二进制模块</h2><p>Node.js 也支持使用 C/C++ 编写二进制模块<br>编译好的二进制模块的扩展名是<code>.node</code>，使用方式与 JS 模块使用方式相同。</p>
<blockquote>
<p>二进制模块难以跨平台，一般情况下不建议使用</p>
</blockquote>
]]></content>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>getImageData方法获取不正确的问题</title>
    <url>/2022/04/02/getImageData-%E8%8E%B7%E5%8F%96%E4%B8%8D%E6%AD%A3%E7%A1%AE%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>本篇分析getImageData()方法无法在画布旋转后正确获取指定区域的ImageData的原因以及解决方法</p>
<a id="more"></a>

<h1 id="getImageData-无法正确获取ImageData的问题"><a href="#getImageData-无法正确获取ImageData的问题" class="headerlink" title="getImageData()无法正确获取ImageData的问题"></a>getImageData()无法正确获取ImageData的问题</h1><h2 id="getImageData"><a href="#getImageData" class="headerlink" title="getImageData()"></a>getImageData()</h2><h3 id="接口简介"><a href="#接口简介" class="headerlink" title="接口简介"></a>接口简介</h3><ul>
<li><strong><code>CanvasRenderingContext2D.getImageData()</code></strong> 返回一个<code>ImageData</code>对象，用来描述canvas区域隐含的像素数据，这个区域通过矩形表示，起始点为(sx, sy)、宽为sw、高为sh。</li>
</ul>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><blockquote>
<p>ImageData ctx.getImageData(sx, sy, sw, sh);</p>
</blockquote>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p><code>sx</code><br>将要被提取的图像数据矩形区域的左上角 x 坐标。</p>
<p><code>sy</code><br>将要被提取的图像数据矩形区域的左上角 y 坐标。</p>
<p><code>sw</code><br>将要被提取的图像数据矩形区域的宽度。</p>
<p><code>sh</code><br>将要被提取的图像数据矩形区域的高度。</p>
<h2 id="错误原因"><a href="#错误原因" class="headerlink" title="错误原因"></a>错误原因</h2><h3 id="translate-amp-rotate"><a href="#translate-amp-rotate" class="headerlink" title="translate() &amp; rotate()"></a>translate() &amp; rotate()</h3><p>translate()和rotate()方法本质上是修改当前变换矩阵，以达到平移/旋转的效果：</p>
<blockquote>
<p>The  <code>rotate(angle)</code>  method, when invoked, must run these steps:</p>
<ol>
<li>If  angle  is infinite or NaN, then return.  </li>
<li>Add the rotation transformation described by the argument to the  <a href="https://html.spec.whatwg.org/multipage/canvas.html#current-transformation-matrix" target="_blank" rel="noopener">current transformation matrix</a>. The  angle  argument represents a clockwise rotation angle expressed in radians.</li>
</ol>
</blockquote>
<blockquote>
<p>The  <code>translate(x,  y)</code>  method, when invoked, must run these steps:</p>
<ol>
<li>If either of the arguments are infinite or NaN, then return. </li>
<li>Add the translation transformation described by the arguments to the  <a href="https://html.spec.whatwg.org/multipage/canvas.html#current-transformation-matrix" target="_blank" rel="noopener">current transformation matrix</a>. The  x  argument represents the translation distance in the horizontal direction and the  y  argument represents the translation distance in the vertical direction. The arguments are in coordinate space units.</li>
</ol>
</blockquote>
<blockquote>
<p>摘自<a href="https://html.spec.whatwg.org/multipage/canvas.html#dom-context-2d-rotate" target="_blank" rel="noopener">https://html.spec.whatwg.org/multipage/canvas.html#dom-context-2d-rotate</a></p>
</blockquote>
<h3 id="getImageData-的特性"><a href="#getImageData-的特性" class="headerlink" title="getImageData()的特性"></a>getImageData()的特性</h3><p><code>createImageData()</code>、<code>getImageData()</code>、<code>putImageData()</code>等方法具有不受当前路径、变换矩阵、阴影属性、全局 alpha、裁剪区域和全局合成算子影响的特性：</p>
<blockquote>
<p>The current path, <a href="https://html.spec.whatwg.org/multipage/canvas.html#transformations" target="_blank" rel="noopener">transformation matrix</a>, <a href="https://html.spec.whatwg.org/multipage/canvas.html#shadows" target="_blank" rel="noopener">shadow attributes</a>, <a href="https://html.spec.whatwg.org/multipage/canvas.html#dom-context-2d-globalalpha" target="_blank" rel="noopener">global alpha</a>, the <a href="https://html.spec.whatwg.org/multipage/canvas.html#clipping-region" target="_blank" rel="noopener">clipping region</a>, and <a href="https://html.spec.whatwg.org/multipage/canvas.html#dom-context-2d-globalcompositeoperation" target="_blank" rel="noopener">global composition operator</a> must not affect the methods described in this section.</p>
</blockquote>
<blockquote>
<p>摘自 <a href="https://html.spec.whatwg.org/multipage/canvas.html#pixel-manipulation" target="_blank" rel="noopener">https://html.spec.whatwg.org/multipage/canvas.html#pixel-manipulation</a></p>
</blockquote>
<h3 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h3><p>假设使用translate()和rotate()之后，绘制<em>宽为20，高为10</em>的矩形如下<br><img src="/2022/04/02/getImageData-%E8%8E%B7%E5%8F%96%E4%B8%8D%E6%AD%A3%E7%A1%AE%E7%9A%84%E9%97%AE%E9%A2%98/image_20220123160743.png" alt><br>蓝色矩形是canvas的边界，黑色矩形是绘制的矩形，当前context的x、y坐标轴如图所示</p>
<p>若此时想要获取绘制的矩形部分的ImageData，很自然的会想到使用<code>getImageData(0, 0, 20, 10)</code>获取ImageData，而由于<strong>getImageData()方法不受变换矩阵影响</strong>，此时调用getImageData方法取到的ImageData实际上是下图黄色区域部分的ImageData<br><img src="/2022/04/02/getImageData-%E8%8E%B7%E5%8F%96%E4%B8%8D%E6%AD%A3%E7%A1%AE%E7%9A%84%E9%97%AE%E9%A2%98/image_20220123161550.png" alt></p>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><ul>
<li>如果只进行了平移操作，则在进行操作的时候手动添加x轴和y轴方向的位移，例如：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ctx.translate(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">ctx.fillRect(<span class="number">0</span>,<span class="number">0</span>,<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> imageData = ctx.getImagedata(<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>如果进行了旋转操作，且旋转角度不是90°的整数倍，则没有很好的办法能准确取到指定矩形的ImageData，此时可以考虑新建另一个canvas元素，在新的canvas上绘制一个相同的图像，再调用<code>getImageData()</code>方法在这个新的canvas中获取ImageData。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ctx.rotate(<span class="number">59</span> * <span class="built_in">Math</span>.PI / <span class="number">180</span>);</span><br><span class="line">ctx.fillRect(<span class="number">0</span>,<span class="number">0</span>,<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">let</span> canvas = <span class="built_in">document</span>.createElement(<span class="string">'canvas'</span>);</span><br><span class="line"><span class="keyword">var</span> context = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">canvas.width = <span class="number">100</span>;</span><br><span class="line">canvas.height = <span class="number">100</span>;</span><br><span class="line">context.fillRect(<span class="number">0</span>,<span class="number">0</span>,<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> imageData = context.getImagedata(<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>将从新canvas中取到的ImageData进行处理后使用<code>putImageData()</code>方法放入原canvas，也可以得到相同的效果</p>
]]></content>
      <tags>
        <tag>前端</tag>
        <tag>canvas</tag>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>node.js学习_3</title>
    <url>/2020/03/03/node-js%E5%AD%A6%E4%B9%A0-3/</url>
    <content><![CDATA[<p>Node.js 学习之三：文件操作<br>摸鱼摸得太久了<br>本文参考：<a href="http://nqdeng.github.io/7-days-nodejs" target="_blank" rel="noopener">http://nqdeng.github.io/7-days-nodejs</a></p>
<a id="more"></a>

<h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>Node.js提供了基本的文件操作API，但是像文件拷贝这种高级功能就没有提供，因此我们先拿文件拷贝程序练手。与<code>copy</code>命令类似，程序需要能接受<em>源文件路径</em> 与<em>目标文件路径</em> 两个参数。</p>
<h3 id="小文件拷贝"><a href="#小文件拷贝" class="headerlink" title="小文件拷贝"></a>小文件拷贝</h3><p>使用Node.js内置的<code>fs</code>模块实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fileCopy</span>(<span class="params">src, dst</span>)</span>&#123;</span><br><span class="line">	fs.writeFileSync(dst, fs.readFileSync(src));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params">argv</span>)</span>&#123;</span><br><span class="line">	fileCopy(argv[<span class="number">0</span>], argv[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main(process.argv.slice(<span class="number">2</span>));</span><br></pre></td></tr></table></figure>

<p>以上程序使用<code>fs.readFileSync</code>从源路径读取文件内容，然后将内容通过<code>fs.writeFileSync</code>写入目标路径</p>
<blockquote>
<p><code>process</code>是一个全局变量，可以通过<code>process.argv</code>获得命令行参数。<br><code>argv[0]</code>固定等于Node.js执行程序的绝对路径，<code>argv[1]</code>固定等于主模块的绝对路径，因此第一个命令行参数从<code>argv[2]</code>开始</p>
</blockquote>
<h3 id="大文件拷贝"><a href="#大文件拷贝" class="headerlink" title="大文件拷贝"></a>大文件拷贝</h3><p>上述程序存在一个问题：它将文件内容<strong>一次性读入内存</strong>，然后一次性写入目标地址，对于大文件来说，可能造成内存溢出。所以在拷贝大文件时，需要进行如下改进：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fileCopy</span>(<span class="params">src, dst</span>)</span>&#123;</span><br><span class="line">	fs.createReadStream(src).pipe(fs.createWriteStream(dst));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params">argv</span>)</span>&#123;</span><br><span class="line">	fileCopy(argv[<span class="number">0</span>], argv[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mian(process.argv.slice(<span class="number">2</span>));</span><br></pre></td></tr></table></figure>
<p>上述程序使用<code>createReadStream</code>创建了源文件的<strong>只读数据流</strong>，然后通过<code>createWriteStream</code>船舰了目标文件的<strong>只写数据流</strong>。并且<strong>用<code>pipe</code>方法将两个数据流连接起来</strong></p>
<h2 id="API概览"><a href="#API概览" class="headerlink" title="API概览"></a>API概览</h2><p>本节只对部分与文件操作相关的API做一个大概的介绍，详情可以查阅官方文档</p>
<h3 id="Buffer（数据块）"><a href="#Buffer（数据块）" class="headerlink" title="Buffer（数据块）"></a>Buffer（数据块）</h3><p>JS 语言自身只有<strong>字符串</strong>数据类型，没有<strong>二进制</strong>数据类型，因此Node.js提供了一个与<code>String</code>对等的<em>全局构造函数</em><code>Buffer</code>来提供对二进制数据的操作<br><strong>Buffer 将 JS 的数据处理能力从字符串扩展到了任意二进制数据</strong></p>
<p>除了可以读取文件得到Buffer的实例外，还能够直接构造，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bin = <span class="keyword">new</span> Buffer([<span class="number">0x68</span>, <span class="number">0x65</span>, <span class="number">0x6c</span>, <span class="number">0x6c</span>, <span class="number">0x6f</span>]);</span><br></pre></td></tr></table></figure>

<p>与字符串类似，Buffer除了可以用<code>.length</code>属性得到字节长度外，还可以用<code>[index]</code>方式读取指定位置的字节;<br>Buffer 与字符串能够相互转换，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = bin.toString(<span class="string">'utf-8'</span>); <span class="comment">// =&gt; "hello"</span></span><br><span class="line"><span class="comment">//指定编码将二进制数据转化为字符串</span></span><br></pre></td></tr></table></figure>

<p>Buffer 与字符串有一个重要区别：字符串是<strong>只读</strong>的，且对字符串的任何修改得到的都是一个<strong>新字符串</strong>，原字符串保持不变；<br>而 Buffer 类似于数组，可以利用 <code>[index]</code> 方式直接修改某个位置的值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">bin[<span class="number">0</span>] = <span class="number">0x48</span>;</span><br></pre></td></tr></table></figure>

<p>且<code>.slice</code>方法也不返回一个新的 Buffer，而是返回了指向原 Buffer 中指定位置的<strong>指针</strong>（尽管JS中没有指针，但并不妨碍它使用指针的概念）</p>
<p style="color:red">因此，对`.slice`方法返回的Buffer的修改会作用于原Buffer</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bin = <span class="keyword">new</span> Buffer([ <span class="number">0x68</span>, <span class="number">0x65</span>, <span class="number">0x6c</span>, <span class="number">0x6c</span>, <span class="number">0x6f</span> ]);</span><br><span class="line"><span class="keyword">var</span> sub = bin.slice(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">sub[<span class="number">0</span>] = <span class="number">0x65</span>;</span><br><span class="line"><span class="built_in">console</span>.log(bin); <span class="comment">// =&gt; &lt;Buffer 68 65 65 6c 6f&gt;</span></span><br></pre></td></tr></table></figure>

<p>也因此，如果想要拷贝一份 Buffer，得首先创建一个新的 Buffer，并通过<code>.copy</code>方法把原 Buffer 中的数据复制过去，类似于申请一块新内存再复制数据。</p>
<blockquote>
<p>更多内容可参照官方文档： <a href="http://nodejs.org/api/buffer.html" target="_blank" rel="noopener">http://nodejs.org/api/buffer.html</a></p>
</blockquote>
<h3 id="Stream（数据流）"><a href="#Stream（数据流）" class="headerlink" title="Stream（数据流）"></a>Stream（数据流）</h3><p>当内存中无法一次装下需要处理的数据时，或者一边读取一边处理更加高效时，需要用到数据流。<br><strong>Node.js中通过各种Stream来提供对数据流的操作</strong></p>
<p>以上文提到的<em>大文件拷贝</em> 为例，为数据创建一个只读数据流：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rs = fs.creatReadStream(src)</span><br><span class="line"></span><br><span class="line">rs.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>)</span>&#123;</span><br><span class="line">	doSomething(chunk);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">rs.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	cleanUp();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Stream基于事件机制工作，所有Stream的实例都继承于Node.js提供的<a href="https://nodejs.org/api/events.html" target="_blank" rel="noopener"> EventEmitter</a></p>
</blockquote>
<p>上述代码中<code>data</code>事件会被持续触发，不管函数<code>doSomething</code>是否能够处理。故代码可以做如下改造：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rs = fs.creatReadStream(src)</span><br><span class="line"></span><br><span class="line">rs.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>)</span>&#123;</span><br><span class="line">	rs.pause();<span class="comment">//pause方法用于使流动模式的流停止触发 'data' 事件，并切换出流动模式。 任何可用的数据都会保留在内部缓存中。</span></span><br><span class="line">	doSomething(chunk, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		rs.resume();<span class="comment">//resume方法将被暂停的可读流恢复触发 'data' 事件，并将流切换到流动模式</span></span><br><span class="line">	&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">rs.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	cleanUp();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以上代码为<code>doSomething</code>函数增加了回调，因此可以在处理数据前暂停数据读取，并在处理数据后继续读取数据</p>
</blockquote>
<p>此外，可以为数据目标创建一个只写数据流 ：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rs = fs.createReadStream(src);</span><br><span class="line"><span class="keyword">var</span> ws = fs.createWriteStream(dst);</span><br><span class="line"></span><br><span class="line">rs.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">    ws.write(chunk);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">rs.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    ws.end();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>我们把<code>doSomething</code>换成了往只写数据流里写入数据后，以上代码看起来就像是一个文件拷贝程序了。但是以上代码存在上边提到的问题，如果写入速度跟不上读取速度的话，只写数据流内部的缓存会爆仓。对此，Node.js 提供了<code>.pipe</code>方法来实现防爆仓控制</p>
<blockquote>
<p>官方文档：<a href="http://nodejs.org/api/stream.html" target="_blank" rel="noopener">http://nodejs.org/api/stream.html</a></p>
</blockquote>
<h3 id="File-System（文件系统）"><a href="#File-System（文件系统）" class="headerlink" title="File System（文件系统）"></a>File System（文件系统）</h3><p><strong>Node.js 通过内置模块<code>fs</code>实现对文件的操作</strong><br>fs提供的API基本课分为以下三类：</p>
<ul>
<li><p>文件属性读写</p>
<blockquote>
<p>常用的有<code>fs.stat</code>、<code>fs.chmod</code>、<code>fs.chown</code>等</p>
</blockquote>
</li>
<li><p>文件内容读写</p>
<blockquote>
<p>常用的有<code>fs.readFile</code>、<code>fs.readdir</code>、<code>fs.writeFile</code>、<code>fs.mkdir</code>等</p>
</blockquote>
</li>
<li><p>底层文件操作</p>
<blockquote>
<p>常用的有<code>fs.open</code>、<code>fs.read</code>、<code>fs.write</code>、<code>fs.close</code>等</p>
</blockquote>
</li>
</ul>
<p><code>fs</code>充分体现了Node.js <span style="color:red"><em>异步I/O</em></span> 的特性，如上文提到的API都通过<em>回调函数</em> 传递结果，以<code>fs.readFile</code>为例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fs.readFile(pathname, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="comment">// Deal with error.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Deal with data.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如上，基本上所有<code>fs</code>模块API的回调参数都有两个。第一个参数在有错误发生时等于异常对象，第二个参数始终用于返回API方法执行结果<br>此外，<code>fs</code>模块的所有异步API都有对应的同步版本，用于无法使用异步操作时，或者同步操作更方便时的情况；同步API除了方法名的末尾多了一个<strong><em>Sync</em></strong> 之外，异常对象与执行结果的传递方式也有相应变化。同样以<code>fs.readFileSync</code>为例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> data = fs.readFileSync(pathname);</span><br><span class="line">    <span class="comment">// Deal with data.</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="comment">// Deal with error.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>官方文档：<a href="http://nodejs.org/api/fs.html" target="_blank" rel="noopener">http://nodejs.org/api/fs.html</a></p>
</blockquote>
<h3 id="Path（路径）"><a href="#Path（路径）" class="headerlink" title="Path（路径）"></a>Path（路径）</h3><p><strong>内置模块<code>path</code>用于简化路径相关操作，并提升相关代码可读性</strong></p>
<p>常用API：</p>
<ul>
<li>path.normalize<br>将传入的路径转换为<em>标准路径</em> ，如下：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cache = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">store</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">    cache[path.normalize(key)] = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">store(<span class="string">'foo/bar'</span>, <span class="number">1</span>);</span><br><span class="line">store(<span class="string">'foo//baz//../bar'</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(cache);  <span class="comment">// =&gt; &#123; "foo/bar": 2 &#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>除了解析路径中的.与..外，还能去掉多余的斜杠。如果有程序需要使用路径作为某些数据的索引，但又允许用户随意输入路径时，就需要使用该方法保证路径的唯一性</p>
</blockquote>
</li>
</ul>
<p><span style="color:red"> 注意：</span>标准化之后的路径里的斜杠在Windows系统下是<code>\</code>，而在Linux系统下是<code>/</code>。如果想保证任何系统下都使用<code>/</code>作为路径分隔符的话，需要用<code>.replace(/\\/g, &#39;/&#39;)</code>再替换一下标准路径</p>
<ul>
<li><p>path.join<br>将传入的多个路径拼接为标准路径，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">path.join(<span class="string">'foo/'</span>, <span class="string">'baz/'</span>, <span class="string">'../bar'</span>); <span class="comment">// =&gt; "foo/bar"</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>该方法可避免手工拼接路径字符串的繁琐，并且能在不同系统下正确使用相应的路径分隔符</p>
</blockquote>
</li>
<li><p>path.extname<br>返回文件扩展名，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">path.extname(<span class="string">'foo/bar.js'</span>); <span class="comment">//=&gt;".js"</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>官方文档：<a href="http://nodejs.org/api/path.html" target="_blank" rel="noopener">http://nodejs.org/api/path.html</a></p>
</blockquote>
<h2 id="遍历目录"><a href="#遍历目录" class="headerlink" title="遍历目录"></a>遍历目录</h2><h3 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h3><p>递归算法代码简洁，是最常使用的方法，但由于每次递归会产生一次函数调用，在需要优先考虑性能时，需要把递归算法转换为循环算法，以减少函数调用次数</p>
<h3 id="遍历算法"><a href="#遍历算法" class="headerlink" title="遍历算法"></a>遍历算法</h3><p>目录是一个树状结构，在遍历时一般使用<strong>深度优先+先序遍历</strong>算法</p>
<ul>
<li>深度优先：到达一个节点时，下一步先遍历其子节点，子节点遍历结束后才遍历邻居节点</li>
<li>先序遍历：首次到达某节点就访问该节点，而不是等到返回节点时才访问</li>
</ul>
<h3 id="同步遍历"><a href="#同步遍历" class="headerlink" title="同步遍历"></a>同步遍历</h3><p>掌握必要算法之后，可以简单实现目录遍历，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">travel</span>(<span class="params">dir, callback</span>)</span>&#123;</span><br><span class="line">	fs.readdirSync(dir).forEach(<span class="function"><span class="keyword">function</span> (<span class="params">file</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">var</span> pathname = path.join(dir, file);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(fs.statSync(pathname).isDirectory())&#123;</span><br><span class="line">			travel(pathname, callback);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			callback(pathname);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数以某个目录作为遍历起点，遇到子目录先遍历子目录，遇到文件就将文件的绝对路径传给回调函数，回调函数拿到文件路径后就可以进行处理；<br>假设有以下目录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- &#x2F;home&#x2F;user&#x2F;</span><br><span class="line">    - foo&#x2F;</span><br><span class="line">        x.js</span><br><span class="line">    - bar&#x2F;</span><br><span class="line">        y.js</span><br><span class="line">    z.css</span><br></pre></td></tr></table></figure>

<p>使用以下代码遍历该目录时，得到的输入如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">travel(&#39;&#x2F;home&#x2F;user&#39;, function (pathname) &#123;</span><br><span class="line">    console.log(pathname);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">------------------------</span><br><span class="line">&#x2F;home&#x2F;user&#x2F;foo&#x2F;x.js</span><br><span class="line">&#x2F;home&#x2F;user&#x2F;bar&#x2F;y.js</span><br><span class="line">&#x2F;home&#x2F;user&#x2F;z.css</span><br></pre></td></tr></table></figure>

<h3 id="异步遍历"><a href="#异步遍历" class="headerlink" title="异步遍历"></a>异步遍历</h3><p>若读取目录/读取状态文件时使用异步API，实现如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">travel</span>(<span class="params">dir, callback, finish</span>) </span>&#123;</span><br><span class="line">    fs.readdir(dir, <span class="function"><span class="keyword">function</span> (<span class="params">err, files</span>) </span>&#123;</span><br><span class="line">        (<span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; files.length) &#123;</span><br><span class="line">                <span class="keyword">var</span> pathname = path.join(dir, files[i]);</span><br><span class="line"></span><br><span class="line">                fs.stat(pathname, <span class="function"><span class="keyword">function</span> (<span class="params">err, stats</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (stats.isDirectory()) &#123;</span><br><span class="line">                        travel(pathname, callback, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                            next(i + <span class="number">1</span>);</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        callback(pathname, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                            next(i + <span class="number">1</span>);</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                finish &amp;&amp; finish();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(<span class="number">0</span>));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里不详细介绍异步遍历函数的编写技巧，在后续章节中会详细介绍这个。总之我们可以看到异步编程还是蛮复杂的</p>
<h2 id="文本编码"><a href="#文本编码" class="headerlink" title="文本编码"></a>文本编码</h2><p>使用 Node.js 编写前端工具时，经常操作文本文件，故时常涉及文件编码的处理问题。<br>常用的文件编码有<code>GBK</code>和<code>UTF-8</code>编码，<code>UTF-8</code>编码可能带有<code>BOM</code>。再读取不同编码的文本文件时，需要将文件内容转换为JS用的<code>UTF-8</code>编码字符串后才能正常处理。</p>
<h3 id="BOM移除"><a href="#BOM移除" class="headerlink" title="BOM移除"></a>BOM移除</h3><p>BOM(<em>Byte Order Mark</em>)，字节顺序标记，出现在文本文件头部，Unicode编码标准中用于标识文件是采用哪种格式的编码，详情参见<a href="https://baike.baidu.com/item/BOM/2790364#viewPageContent" target="_blank" rel="noopener">百度百科</a></p>
<p>在不同Unicode编码下，BOM字符对应格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    Bytes      Encoding</span><br><span class="line">----------------------------</span><br><span class="line">    FE FF       UTF16BE</span><br><span class="line">    FF FE       UTF16LE</span><br><span class="line">    EF BB BF    UTF8</span><br></pre></td></tr></table></figure>

<p>某些场景下，在读取文件时不去掉BOM会导致出错：例如将几个JS文件合并成一个文件后，如果文件中间含有BOM字符，就会导致浏览器JS语法错误。以下代码实现了识别和去除UTF-8 BOM的功能</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readText</span>(<span class="params">pathname</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> bin = fs.readFileSync(pathname);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bin[<span class="number">0</span>] === <span class="number">0xEF</span> &amp;&amp; bin[<span class="number">1</span>] === <span class="number">0xBB</span> &amp;&amp; bin[<span class="number">2</span>] === <span class="number">0xBF</span>) &#123;</span><br><span class="line">        bin = bin.slice(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bin.toString(<span class="string">'utf-8'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="GBK转UTF-8"><a href="#GBK转UTF-8" class="headerlink" title="GBK转UTF-8"></a>GBK转UTF-8</h3><p>Node.js 支持在读取文本文件时，或者在Buffer转换为字符串时指定文本编码，但GBK编码不在Node.js自身支持范围内。一般需要借助三方包<code>iconv-lite</code>实现功能，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> iconv = <span class="built_in">require</span>(<span class="string">'iconv-lite'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readGBKText</span>(<span class="params">pathname</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> bin = fs.readFileSync(pathname);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> iconv.decode(bin, <span class="string">'gbk'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="单字节编码"><a href="#单字节编码" class="headerlink" title="单字节编码"></a>单字节编码</h3><p>有时候，我们无法预知需要读取的文件采用哪种编码，因此也就无法指定正确的编码。比如我们要处理的某些CSS文件中，有的用GBK编码，有的用UTF8编码。虽然可以一定程度可以根据文件的字节内容猜测出文本编码，但这里要介绍的是有些局限，但是要简单得多的一种技术。</p>
<p>首先我们知道，如果一个文本文件只包含英文字符，比如<code>Hello World</code>，那无论用GBK编码或是UTF8编码读取这个文件都是没问题的。这是因为在这些编码下，ASCII0~128范围内字符都使用相同的单字节编码。</p>
<p>反过来讲，即使一个文本文件中有中文等字符，如果我们需要处理的字符仅在ASCII0~128范围内，比如除了注释和字符串以外的JS代码，我们就可以统一使用单字节编码来读取文件，不用关心文件的实际编码是GBK还是UTF8。以下示例说明了这种方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. GBK编码源文件内容：</span><br><span class="line">    var foo &#x3D; &#39;中文&#39;;</span><br><span class="line">2. 对应字节：</span><br><span class="line">    76 61 72 20 66 6F 6F 20 3D 20 27 D6 D0 CE C4 27 3B</span><br><span class="line">3. 使用单字节编码读取后得到的内容：</span><br><span class="line">    var foo &#x3D; &#39;&#123;乱码&#125;&#123;乱码&#125;&#123;乱码&#125;&#123;乱码&#125;&#39;;</span><br><span class="line">4. 替换内容：</span><br><span class="line">    var bar &#x3D; &#39;&#123;乱码&#125;&#123;乱码&#125;&#123;乱码&#125;&#123;乱码&#125;&#39;;</span><br><span class="line">5. 使用单字节编码保存后对应字节：</span><br><span class="line">    76 61 72 20 62 61 72 20 3D 20 27 D6 D0 CE C4 27 3B</span><br><span class="line">6. 使用GBK编码读取后得到内容：</span><br><span class="line">    var bar &#x3D; &#39;中文&#39;;</span><br></pre></td></tr></table></figure>

<p>这里的诀窍在于，不管大于0xEF的单个字节在单字节编码下被解析成什么乱码字符，使用同样的单字节编码保存这些乱码字符时，背后对应的字节保持不变。</p>
<p>NodeJS中自带了一种<code>binary</code>编码可以用来实现这个方法，因此在下例中，我们使用这种编码来演示上例对应的代码该怎么写。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function replace(pathname) &#123;</span><br><span class="line">    var str &#x3D; fs.readFileSync(pathname, &#39;binary&#39;);</span><br><span class="line">    str &#x3D; str.replace(&#39;foo&#39;, &#39;bar&#39;);</span><br><span class="line">    fs.writeFileSync(pathname, str, &#39;binary&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>vue+SpringBoot前后端分离开发</title>
    <url>/2022/02/20/vue-SpringBoot%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<p>本文介绍前后端分离开发的基本环境搭建</p>
<a id="more"></a>

<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在弄学校课程的前端图像处理项目，想着正好把vue和前后端分离这方面的东西顺便学一下，于是打算拿这个项目练手。</p>
<h2 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h2><p>前后端项目均在GitHub上开源，地址如下：</p>
<blockquote>
<p>前端：<a href="https://github.com/Table-the-cat/webip" target="_blank" rel="noopener">https://github.com/Table-the-cat/webip</a><br>后端：<a href="https://github.com/Table-the-cat/webip-server" target="_blank" rel="noopener">https://github.com/Table-the-cat/webip-server</a></p>
</blockquote>
<h2 id="SpringBoot项目"><a href="#SpringBoot项目" class="headerlink" title="SpringBoot项目"></a>SpringBoot项目</h2><h3 id="搭建SpringBoot项目"><a href="#搭建SpringBoot项目" class="headerlink" title="搭建SpringBoot项目"></a>搭建SpringBoot项目</h3><p>访问网页 <a href="http://start.spring.io/" target="_blank" rel="noopener">http://start.spring.io/</a> ，填写必要信息后下载项目压缩包。</p>
<blockquote>
<p>Project：选择使用Maven还是Gradle来构建项目<br>Language：选择项目使用的语言<br>SpringBoot：选择SpringBoot版本</p>
<p>Project Metadata：</p>
<blockquote>
<p>Group：项目组织唯一的标识符，实际对应项目中的package包<br>Artifect：项目的唯一的标识符，实际对应项目的project name名称，Artifact不可包含大写字母<br>Name：项目名<br>Description：项目描述</p>
</blockquote>
</blockquote>
<p>解压后用IDEA打开项目，IDEA会自动扫描pom文件并开始安装依赖，也可以通过<code>Maven-&gt;Lifecycle-&gt;install</code>来手动安装依赖。</p>
<h3 id="基本准备"><a href="#基本准备" class="headerlink" title="基本准备"></a>基本准备</h3><p>因为要做前后端分离，在SpringBoot项目里做的自然是纯后端的工作，主要有以下方面的准备：</p>
<ul>
<li>数据库</li>
<li>数据库访问框架（本项目使用MyBatis）</li>
<li>定义与数据库数据对应的实体类（pojo层）</li>
<li>编写mapper文件，包括<code>resource/mapper</code>路径下的xml文件和<code>java/com/table/webip/mapper</code>路径下的java文件（dao层）</li>
<li>编写对应的service和serviceImpl文件（service层）</li>
<li>编写controller文件（controller层）</li>
</ul>
<p>准备完毕之后，需要修改配置文件<code>application.properties</code>，为项目配置数据源和MyBatis：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## 数据源配置</span><br><span class="line">spring.datasource.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;jdbc?useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8&amp;autoReconnect&#x3D;true&amp;failOverReadOnly&#x3D;false</span><br><span class="line">spring.datasource.username&#x3D;root</span><br><span class="line">spring.datasource.password&#x3D;jiang</span><br><span class="line">spring.datasource.driver-class-name&#x3D;com.mysql.jdbc.Driver</span><br><span class="line"></span><br><span class="line">## Mybatis 配置</span><br><span class="line"># 配置为 com.pancm.bean 指向实体类包路径。</span><br><span class="line">mybatis.type-aliases-package&#x3D;com.table.webip</span><br><span class="line"># 配置为 classpath 路径下 mapper 包下，* 代表会扫描所有 xml 文件，如果不配置该项，项目将扫描不到mapper文件。</span><br><span class="line">mybatis.mapper-locations&#x3D;classpath:mapper&#x2F;*.xml</span><br><span class="line">#mybatis.configuration.map-underscore-to-camel-case&#x3D;true  </span><br><span class="line">spring.aop.auto&#x3D;true</span><br></pre></td></tr></table></figure>

<h3 id="试运行"><a href="#试运行" class="headerlink" title="试运行"></a>试运行</h3><p>运行<code>WebipApplication.java</code>文件，启动项目，项目默认运行在8080端口上。</p>
<h2 id="Vue项目"><a href="#Vue项目" class="headerlink" title="Vue项目"></a>Vue项目</h2><h3 id="搭建Vue项目"><a href="#搭建Vue项目" class="headerlink" title="搭建Vue项目"></a>搭建Vue项目</h3><p>首先列出大致步骤：</p>
<ul>
<li>安装node.js</li>
<li>安装webpack</li>
<li>安装vue-cli</li>
<li>初始化Vue项目</li>
<li>试运行</li>
</ul>
<h4 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h4><p>在官网下载安装即可。<br>使用<code>node -v</code>指令检查是否安装成功，输出版本号即为安装成功。</p>
<h4 id="安装webpack"><a href="#安装webpack" class="headerlink" title="安装webpack"></a>安装webpack</h4><p>webpack是一款开源的前端打包工具。<br>使用<code>cnpm install webpack -g</code>指令进行全局安装，安装完成之后输入 <code>webpack -v</code>检查是否安装成功。</p>
<h4 id="安装vue-cli"><a href="#安装vue-cli" class="headerlink" title="安装vue-cli"></a>安装vue-cli</h4><p>使用<code>cnpm install vue-cli -g</code>指令进行全局安装，安装完成之后输入 <code>vue -V</code>（注意<strong>大写</strong>）检查是否安装成功。</p>
<h4 id="初始化Vue项目"><a href="#初始化Vue项目" class="headerlink" title="初始化Vue项目"></a>初始化Vue项目</h4><p>在想创建项目的文件夹中右键，在右键菜单中选择Git Bash Here，打开命令行窗口，输入指令<code>vue init webpack project_name</code>，用project_name处替换为自己的项目名。<br>创建好之后进入该项目文件夹，在项目路径下输入指令<code>npm install</code>安装项目所需依赖。</p>
<h4 id="试运行-1"><a href="#试运行-1" class="headerlink" title="试运行"></a>试运行</h4><p>输入指令<code>npm run dev</code>启动项目，如果此时你的后端SpringBoot项目仍在运行，则该项目应该会运行在8081端口上。访问localhost:8081便可以看见vue自动生成的初始界面。</p>
<h2 id="整合"><a href="#整合" class="headerlink" title="整合"></a>整合</h2><p>当前后端项目运行在8080端口，而前端项目运行在8081端口，前端需要设置代理才能正常向后端发送请求。</p>
<h3 id="main-js"><a href="#main-js" class="headerlink" title="main.js"></a>main.js</h3><p>加入如下代码：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置全局的axios</span></span><br><span class="line">Vue.prototype.$axios=Axios</span><br><span class="line"><span class="comment">// 设置基本路径</span></span><br><span class="line">Axios.defaults.baseURL=<span class="string">'/api'</span></span><br></pre></td></tr></table></figure>

<h3 id="config-index-js"><a href="#config-index-js" class="headerlink" title="config/index.js"></a>config/index.js</h3><p>将proxyTable的内容替换为如下代码：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">proxyTable: &#123;</span><br><span class="line">  <span class="string">'/api'</span>:&#123;</span><br><span class="line">    target:<span class="string">"http://localhost:8080/"</span>,</span><br><span class="line">    changeOrigin:<span class="literal">true</span>,</span><br><span class="line">    pathRewrite:&#123;</span><br><span class="line">      <span class="string">'^/api'</span>:<span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>此时便可以正常向后端发送请求。</p>
]]></content>
      <tags>
        <tag>vue</tag>
        <tag>SpringBoot</tag>
        <tag>前后端分离开发</tag>
      </tags>
  </entry>
  <entry>
    <title>node.js学习_4</title>
    <url>/2020/03/18/node-js%E5%AD%A6%E4%B9%A0-4/</url>
    <content><![CDATA[<p>Node.js 学习之四：网络操作</p>
<p>本文参考：<a href="http://nqdeng.github.io/7-days-nodejs" target="_blank" rel="noopener">http://nqdeng.github.io/7-days-nodejs</a></p>
<a id="more"></a>

<h1 id="网络操作"><a href="#网络操作" class="headerlink" title="网络操作"></a>网络操作</h1><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>Node.js 本来的用途是编写高性能Web服务器。我妈可以使用其内置的<code>http</code>模块简单实现一个HTTP服务器：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">request, respons</span>)</span>&#123;</span><br><span class="line">	respons.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-Type'</span>, <span class="string">'text-plain'</span>&#125;);</span><br><span class="line">	respons.end(<span class="string">'Hello World\n'</span>);</span><br><span class="line">&#125;).listen(<span class="number">8124</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以上程序创建了一个HTTP服务器并监听<code>8124</code>端口，打开浏览器访问该端口<code>http://127.0.0.1:8124/</code> 就能够看到效果</p>
</blockquote>
]]></content>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/02/12/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>从零开始的Flutter开发_Day2</title>
    <url>/2020/05/04/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84Flutter%E5%BC%80%E5%8F%91-Day2/</url>
    <content><![CDATA[<p>主要内容为如何在Flutter中构建布局，参照<a href="https://flutterchina.club/tutorials/layout/" target="_blank" rel="noopener">Flutter中文网</a></p>
<a id="more"></a>

<h1 id="在Flutter中构建布局"><a href="#在Flutter中构建布局" class="headerlink" title="在Flutter中构建布局"></a>在Flutter中构建布局</h1><h2 id="Flutter的布局方法"><a href="#Flutter的布局方法" class="headerlink" title="Flutter的布局方法"></a>Flutter的布局方法</h2><blockquote>
<p><strong>重点</strong></p>
</blockquote>
<pre><code>- Widget 是用于构建 UI 的类
- Widget 用于布局和 UI 元素
- 通过简单的 Widget 构建复杂的 Widget</code></pre><p>Flutter 布局机制的<strong>核心</strong>就是 <em>Widget</em>；<br>在 Flutter 中，几乎所有东西都是一个 Widget；</p>
<blockquote>
<p>您在Flutter应用中看到的图像、图标和文本都是widget。 甚至你看不到的东西也是widget，例如行（row）、列（column）以及用来排列、约束和对齐这些可见widget的网格（grid）</p>
</blockquote>
<h3 id="复杂的widget"><a href="#复杂的widget" class="headerlink" title="复杂的widget"></a>复杂的widget</h3><p>如下图，有三个图标，每个图标下有一个标签：<br><img src="/2020/05/04/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84Flutter%E5%BC%80%E5%8F%91-Day2/icons.png" alt="Example"><br>该截图显示布局结构，表示一行包括3列，其中每列包含一个图标（icon）和一个标签</p>
<blockquote>
<p>如果希望显示布局情况，需要以下两步：<br>1.在<code>mian.dart</code>中声明引入包<code>import &#39;package:flutter/rendering.dart&#39;;</code><br>2.在主函数中声明<code>debugPaintSizeEnabled = true;</code></p>
</blockquote>
<p>上述 UI 的 widget 树如下：<br><img src="/2020/05/04/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84Flutter%E5%BC%80%E5%8F%91-Day2/layoutTree.png" alt="widgetTree"></p>
<h3 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h3><p>上图很容易理解，但是 Container 的存在可能令人疑惑</p>
<h4 id="Container是什么"><a href="#Container是什么" class="headerlink" title="Container是什么"></a>Container是什么</h4><p><code>Container</code> 可让您创建矩形视觉元素。<code>Container</code> 可以装饰为一个<code>BoxDecoration</code>, 如 background、一个边框、或者一个阴影。 <code>Container</code> 也可以具有边距（margins）、填充(padding)和应用于其大小的约束(constraints)。另外， <code>Container</code>  可以使用矩阵在三维空间中对其进行变换</p>
<h4 id="为什么要有Container"><a href="#为什么要有Container" class="headerlink" title="为什么要有Container"></a>为什么要有Container</h4><p>如果要添加<em>填充，边距，边框或背景色</em>，要使用 Container 来设置，<strong>只有 Container 有这些属性</strong></p>
<blockquote>
<p>在这个例子中，每个 Text 放置在 Container 中以添加边距。整个行也被放置在容器中以在行的周围添加填充</p>
</blockquote>
<h2 id="布局一个Widget"><a href="#布局一个Widget" class="headerlink" title="布局一个Widget"></a>布局一个Widget</h2><p>在 Flutter 中，在屏幕上放置文本，图标或图像大致需要以下几个步骤</p>
<h4 id="选择一个widget保存该对象"><a href="#选择一个widget保存该对象" class="headerlink" title="选择一个widget保存该对象"></a>选择一个widget保存该对象</h4><p>从<em>布局 widget</em> 中进行选择，<em>布局 widget</em> 用于排列其它 widget 的 columns、rows、grids 和其它的 layouts。</p>
<h4 id="创建一个widget来容纳可见对象"><a href="#创建一个widget来容纳可见对象" class="headerlink" title="创建一个widget来容纳可见对象"></a>创建一个widget来容纳可见对象</h4><p>例如，创建一个 <strong>Text widget</strong>：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Text(<span class="string">'Hello World'</span>, style: <span class="keyword">new</span> TextStyle(fontSize: <span class="number">32.0</span>))</span><br></pre></td></tr></table></figure>

<p>创建一个 <strong>Text widget</strong>：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Image.asset(<span class="string">'foo/bar.jpg'</span>, fit: BoxFit.cover)</span><br></pre></td></tr></table></figure>

<p>创建一个 <strong>Text widget</strong>：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Icon(Icons.star, color: Colors.red[<span class="number">500</span>])</span><br></pre></td></tr></table></figure>

<h4 id="将可见widget添加到布局widget"><a href="#将可见widget添加到布局widget" class="headerlink" title="将可见widget添加到布局widget"></a>将可见widget添加到布局widget</h4><p><em>布局 widget</em> 都含有<code>child</code>属性（如<em>Container、Padding、Center</em>）或者<code>children</code>属性（如<em>Row、Column、Stack</em>），子 widget 会继承<em>布局 widget</em>的某些属性以实现布局效果</p>
<p>将Text widget添加到Center widget：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Center(</span><br><span class="line">	child: <span class="keyword">new</span> Text(<span class="string">'Hello World'</span>, style: <span class="keyword">new</span> TextStyle(fontSize: <span class="number">32.0</span>))</span><br><span class="line">	)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Center可以将内容水平和垂直居中</p>
</blockquote>
<h4 id="将布局widget添加到页面"><a href="#将布局widget添加到页面" class="headerlink" title="将布局widget添加到页面"></a>将布局widget添加到页面</h4><p><strong>Flutter 本身就是一个 widget</strong>，大部分widget都有一个<code>build()</code>方法。在应用程序的<code>build()</code>方法中创建会在设备上显示的widget。<br>对于Material应用程序，我们可以将<em>Center widget</em>直接添加到<code>body</code>属性中：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span><br><span class="line">	<span class="meta">@override</span></span><br><span class="line">	Widget build(BuildContext context) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Scaffold(</span><br><span class="line">			appBar: <span class="keyword">new</span> appBar(</span><br><span class="line">				title: <span class="keyword">new</span> Text(widget.title),</span><br><span class="line">			),</span><br><span class="line">			body: <span class="keyword">new</span> Center(</span><br><span class="line">				child: <span class="keyword">new</span> Text(<span class="string">'Hello World'</span>, style: <span class="keyword">new</span> TextStyle(fontSize: <span class="number">32.0</span>)),</span><br><span class="line">			),</span><br><span class="line">		);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>对于非Material应用程序，我们可以将Center widget添加到应用程序的<code>build()</code>方法中：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">	runApp(<span class="keyword">new</span> MyApp());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">	<span class="meta">@override</span></span><br><span class="line">	Widget build(BuildContext context) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Container(</span><br><span class="line">			decoration: <span class="keyword">new</span> BoxDecoration(color: Colors.white),</span><br><span class="line">			child: <span class="keyword">new</span> Center(</span><br><span class="line">				<span class="string">'Hello World'</span>,</span><br><span class="line">				textDirection: TextDirection.ltr,</span><br><span class="line">				style: <span class="keyword">new</span> TextStyle(fontSize: <span class="number">40.0</span>, color: Colors.black87)),</span><br><span class="line">			),</span><br><span class="line">		);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><span style="color: red">注意：</span> 默认情况下，<strong>非Material应用程序不包含AppBar，标题或背景颜色</strong>。 如果要在非Material应用程序中使用这些功能，则必须自己构建它们</p>
</blockquote>
<h2 id="垂直-水平放置多个widget"><a href="#垂直-水平放置多个widget" class="headerlink" title="垂直/水平放置多个widget"></a>垂直/水平放置多个widget</h2><p>最常见的布局模式<br>1.使用行 <code>Row</code> <strong>水平</strong>排列widget；<br>2.使用列 <code>Column</code> <strong>垂直</strong>排列widget</p>
<p>将一个 <em>widget 列表</em>添加到<code>Row</code>中以创建行，添加到<code>Column</code>中以创建列</p>
<blockquote>
<p>“添加”到<code>Row</code>/<code>Column</code>中，即将 widget 列表添加至<code>children</code>属性中</p>
</blockquote>
<p>每个孩子本身可以是一个<code>Row</code>或一个<code>Column</code>，依此类推<br>以下示例显示如何在行或列内嵌套行或列:<br><img src="/2020/05/04/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84Flutter%E5%BC%80%E5%8F%91-Day2/pavlova-diagram.png" alt="Row/Col Nest"></p>
<h3 id="对齐widgets"><a href="#对齐widgets" class="headerlink" title="对齐widgets"></a>对齐widgets</h3><p>利用<code>mainAxisAlignment</code>和<code>crossAxisAlignment</code>属性来对其行/列的子项，这两个属性在<code>Row</code>/<code>Column</code>中的体现如下图：<br><img src="/2020/05/04/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84Flutter%E5%BC%80%E5%8F%91-Day2/row-diagram.png" alt="row">)<img src="/2020/05/04/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84Flutter%E5%BC%80%E5%8F%91-Day2/column-diagram.png" alt="col"><br><a href="https://api.flutter.dev/flutter/rendering/MainAxisAlignment-class.html" target="_blank" rel="noopener">MainAxisAlignment</a> 和 <a href="https://api.flutter.dev/flutter/rendering/CrossAxisAlignment-class.html" target="_blank" rel="noopener">CrossAxisAlignment</a> 类提供了很多控制对齐的常量</p>
<h4 id="MainAxisAlignment中的常量"><a href="#MainAxisAlignment中的常量" class="headerlink" title="MainAxisAlignment中的常量"></a>MainAxisAlignment中的常量</h4><ul>
<li>center：子项居中排列，<strong>子项之间没有间隔</strong></li>
<li>end：子项靠近 main axis 的末尾排列</li>
<li>spaceAround：子项间的间隔相等，且第一个子项之前和最后一个子项之后的间隔是子项间间隔的一半</li>
<li>spaceBetween：子项间间隔相等，<strong>第一个子项之前和最后一个子项之后没有间隔</strong></li>
<li>spaceEvenly：在每个子项之间，之前和之后均匀分配空闲的空间</li>
<li>start：子项靠近 main axis 的起始排列</li>
</ul>
<h4 id="CrossAxisAlignment中的常量"><a href="#CrossAxisAlignment中的常量" class="headerlink" title="CrossAxisAlignment中的常量"></a>CrossAxisAlignment中的常量</h4><ul>
<li>center：子项的中线与 cross axis 的<strong>中点</strong>对齐，<em>这是默认的对齐方式</em></li>
<li>start：子项靠近 cross axis 的起始排列</li>
<li>end：子项靠近 cross axis 的末尾排列</li>
<li>stretch：要求子项填满整个 cross axis</li>
</ul>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><ol>
<li><p>一列三个图片以<code>spaceBetween</code>方式对齐<br>代码如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> MaterialApp(</span><br><span class="line">     title: <span class="string">'Test'</span>,</span><br><span class="line">     theme: <span class="keyword">new</span> ThemeData(primarySwatch: Colors.blue),</span><br><span class="line">     home: <span class="keyword">new</span> Scaffold(</span><br><span class="line">       appBar: <span class="keyword">new</span> AppBar(title: <span class="keyword">new</span> Text(<span class="string">'Alignment Test'</span>),),</span><br><span class="line">       body: <span class="keyword">new</span> Center(</span><br><span class="line">         child: <span class="keyword">new</span> Column(</span><br><span class="line">           mainAxisAlignment: MainAxisAlignment.spaceBetween,</span><br><span class="line">           children: &lt;Widget&gt;[</span><br><span class="line">             <span class="keyword">new</span> Image.asset(<span class="string">'images/01.jpg'</span>),</span><br><span class="line">             <span class="keyword">new</span> Image.asset(<span class="string">'images/02.jpg'</span>),</span><br><span class="line">             <span class="keyword">new</span> Image.asset(<span class="string">'images/03.jpg'</span>),</span><br><span class="line">           ],</span><br><span class="line">         ),</span><br><span class="line">       ),</span><br><span class="line">     ),</span><br><span class="line">   );</span><br></pre></td></tr></table></figure>
<p>运行结果如图：<br><img src="/2020/05/04/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84Flutter%E5%BC%80%E5%8F%91-Day2/result1.jpg" alt="result1"></p>
<blockquote>
<p>可以看到：第一张图之前和最后一张图之后没有留下空间</p>
</blockquote>
</li>
<li><p>一行三个图片以<code>spaceEvenly</code>方式对齐<br>代码与上方大同小异，运行结果如图：<br><img src="/2020/05/04/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84Flutter%E5%BC%80%E5%8F%91-Day2/result2.jpg" alt="result2"><br><span style="color: red">注意：</span>如果布局太大而不适合设备，则会如上图所示，在受影响的边缘出现黄黑条纹；<br>解决办法：使用 <em>Expanded widget</em>，将widget的大小设置为适和行或列</p>
<blockquote>
<p>后文会详细提及</p>
</blockquote>
</li>
</ol>
<h3 id="调整widget"><a href="#调整widget" class="headerlink" title="调整widget"></a>调整widget</h3><p>如果想要一个 widget 占据其兄弟 widget 两倍的空间，我们可以将行/列的子项放入<em>Expanded widget<em>中，以控制*</em>沿主轴 (main axis) 方向*<em>的 widget 大小<br>*Expanded widget</em>有一个<code>flex</code>属性（整数），用于确定 widget 的弹性系数，*默认为 1</em></p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><ol>
<li>创建一个由三个widget组成的行，其中中间widget的宽度是其他两个widget的两倍<br>代码：<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Column(</span><br><span class="line">   mainAxisAlignment: MainAxisAlignment.spaceBetween,</span><br><span class="line">   children: &lt;Widget&gt;[</span><br><span class="line">            <span class="keyword">new</span> Expanded(child: <span class="keyword">new</span> Image.asset(<span class="string">'images/EVA_01.jpg'</span>)),</span><br><span class="line">            <span class="keyword">new</span> Expanded(</span><br><span class="line">                  flex: <span class="number">2</span>,</span><br><span class="line">                  child: <span class="keyword">new</span> Image.asset(<span class="string">'images/EVA_02.jpg'</span>)</span><br><span class="line">            ),</span><br><span class="line">            <span class="keyword">new</span> Expanded(child: <span class="keyword">new</span> Image.asset(<span class="string">'images/EVA_03.jpg'</span>)),</span><br><span class="line">          ],</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>结果如图：<br><img src="/2020/05/04/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84Flutter%E5%BC%80%E5%8F%91-Day2/result3.jpg" alt="result3"></p>
<ol start="2">
<li>修复上一节中的示例：<br>将上一节代码中所有的<code>new Image.asset()</code>用<code>new Expanded()</code>包裹，如下：<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Expanded(child: <span class="keyword">new</span> Image.asset(<span class="string">'images/01.jpg'</span>)</span><br></pre></td></tr></table></figure>
默认情况下，每个widget的弹性系数为1，将行的三分之一分配给每个小部件</li>
</ol>
<h3 id="聚集widgets"><a href="#聚集widgets" class="headerlink" title="聚集widgets"></a>聚集widgets</h3><p>默认情况下，行或列沿着其主轴会尽可能占用<strong>尽可能多的空间</strong>，但如果要将孩子紧密聚集在一起，可以将<code>mainAxisSize</code>设置为<code>MainAxisSize.min</code>，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> packedRow = <span class="keyword">new</span> Row(</span><br><span class="line">     mainAxisSize: MainAxisSize.min,</span><br><span class="line">     children: [</span><br><span class="line">       <span class="keyword">new</span> Icon(Icons.star, color: Colors.green[<span class="number">500</span>]),</span><br><span class="line">       <span class="keyword">new</span> Icon(Icons.star, color: Colors.green[<span class="number">500</span>]),</span><br><span class="line">       <span class="keyword">new</span> Icon(Icons.star, color: Colors.green[<span class="number">500</span>]),</span><br><span class="line">       <span class="keyword">new</span> Icon(Icons.star, color: Colors.black),</span><br><span class="line">       <span class="keyword">new</span> Icon(Icons.star, color: Colors.black),</span><br><span class="line">     ],</span><br><span class="line">   );</span><br></pre></td></tr></table></figure>

<h3 id="行-列的嵌套"><a href="#行-列的嵌套" class="headerlink" title="行/列的嵌套"></a>行/列的嵌套</h3><p><img src="/2020/05/04/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84Flutter%E5%BC%80%E5%8F%91-Day2/nest-result.png" alt="nest1"><br>实现图中红框部分的布局</p>
<ol>
<li><p>构造<em>评分行</em>的widget树：<br><img src="/2020/05/04/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84Flutter%E5%BC%80%E5%8F%91-Day2/nest-widget-tree.png" alt="widgetTree"><br>根据该树编写代码如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ratingRow = <span class="keyword">new</span> Container(</span><br><span class="line">      padding: <span class="keyword">new</span> EdgeInsets.all(<span class="number">20.0</span>),</span><br><span class="line">      child: <span class="keyword">new</span> Row(</span><br><span class="line">        mainAxisAlignment: MainAxisAlignment.spaceEvenly,</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          <span class="keyword">new</span> Row(</span><br><span class="line">            mainAxisSize: MainAxisSize.min,</span><br><span class="line">            children: [</span><br><span class="line">              <span class="keyword">new</span> Icon(Icons.star, color: Colors.black),</span><br><span class="line">              <span class="keyword">new</span> Icon(Icons.star, color: Colors.black),</span><br><span class="line">              <span class="keyword">new</span> Icon(Icons.star, color: Colors.black),</span><br><span class="line">              <span class="keyword">new</span> Icon(Icons.star, color: Colors.black),</span><br><span class="line">              <span class="keyword">new</span> Icon(Icons.star, color: Colors.black),</span><br><span class="line">            ],</span><br><span class="line">          ),</span><br><span class="line">          <span class="keyword">new</span> Text(</span><br><span class="line">            <span class="string">'114514 Reviews'</span>,</span><br><span class="line">            style: <span class="keyword">new</span> TextStyle(</span><br><span class="line">              color: Colors.black,</span><br><span class="line">              fontWeight: FontWeight.w800,</span><br><span class="line">              fontFamily: <span class="string">'Roboto'</span>,</span><br><span class="line">              letterSpacing: <span class="number">0.5</span>,</span><br><span class="line">              fontSize: <span class="number">20.0</span>,</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br></pre></td></tr></table></figure></li>
<li><p>构造评分行下方<em>图标行</em>的widget树：<br><img src="/2020/05/04/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84Flutter%E5%BC%80%E5%8F%91-Day2/nest-widget-tree2.png" alt="widgetTree2"><br>根据该树编写代码如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> descTextStyle = <span class="keyword">new</span> TextStyle(</span><br><span class="line">      color: Colors.black,</span><br><span class="line">      fontWeight: FontWeight.w800,</span><br><span class="line">      fontFamily: <span class="string">'Roboto'</span>,</span><br><span class="line">      letterSpacing: <span class="number">0.5</span>,</span><br><span class="line">      fontSize: <span class="number">18.0</span>,</span><br><span class="line">      height: <span class="number">2.0</span>,</span><br><span class="line">    );<span class="comment">//定义默认Text样式</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> iconRow = DefaultTextStyle.merge(</span><br><span class="line">     <span class="comment">// DefaultTextStyle.merge可以允许您创建一个默认的文本样式</span></span><br><span class="line">     <span class="comment">//该样式会被其所有的子节点继承</span></span><br><span class="line">      style: descTextStyle,</span><br><span class="line">      child: <span class="keyword">new</span> Container(</span><br><span class="line">        padding: <span class="keyword">new</span> EdgeInsets.all(<span class="number">20.0</span>),</span><br><span class="line">        child: <span class="keyword">new</span> Row(</span><br><span class="line">          mainAxisAlignment: MainAxisAlignment.spaceEvenly,</span><br><span class="line">          children: [</span><br><span class="line">            <span class="keyword">new</span> Column(</span><br><span class="line">              children: [</span><br><span class="line">                <span class="keyword">new</span> Icon(Icons.kitchen, color: Colors.green[<span class="number">500</span>]),</span><br><span class="line">                <span class="keyword">new</span> Text(<span class="string">'PREP:'</span>),</span><br><span class="line">                <span class="keyword">new</span> Text(<span class="string">'25 min'</span>),</span><br><span class="line">              ],</span><br><span class="line">            ),</span><br><span class="line">            <span class="keyword">new</span> Column(</span><br><span class="line">              children: [</span><br><span class="line">                <span class="keyword">new</span> Icon(Icons.timer, color: Colors.green[<span class="number">500</span>]),</span><br><span class="line">                <span class="keyword">new</span> Text(<span class="string">'COOK:'</span>),</span><br><span class="line">                <span class="keyword">new</span> Text(<span class="string">'1 hr'</span>),</span><br><span class="line">              ],</span><br><span class="line">            ),</span><br><span class="line">            <span class="keyword">new</span> Column(</span><br><span class="line">              children: [</span><br><span class="line">                <span class="keyword">new</span> Icon(Icons.restaurant, color: Colors.green[<span class="number">500</span>]),</span><br><span class="line">                <span class="keyword">new</span> Text(<span class="string">'FEEDS:'</span>),</span><br><span class="line">                <span class="keyword">new</span> Text(<span class="string">'4-6'</span>),</span><br><span class="line">              ],</span><br><span class="line">            ),</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
</li>
<li><p>整合<br>代码如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> MaterialApp(</span><br><span class="line">      title: <span class="string">'Test'</span>,</span><br><span class="line">      theme: <span class="keyword">new</span> ThemeData(primarySwatch: Colors.blue),</span><br><span class="line">      home: <span class="keyword">new</span> Scaffold(</span><br><span class="line">        appBar: <span class="keyword">new</span> AppBar(title: <span class="keyword">new</span> Text(<span class="string">'Alignment Test'</span>),),</span><br><span class="line">        body: <span class="keyword">new</span> Center(</span><br><span class="line">          child: <span class="keyword">new</span> Container(</span><br><span class="line">            child: <span class="keyword">new</span> Column(</span><br><span class="line">              children: &lt;Widget&gt;[</span><br><span class="line">                ratingRow,</span><br><span class="line">                iconRow,</span><br><span class="line">              ],</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
<p>效果如图：<br><img src="/2020/05/04/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84Flutter%E5%BC%80%E5%8F%91-Day2/nest-result.jpg" alt="nestResult"></p>
</li>
</ol>
<h2 id="常用布局widgets"><a href="#常用布局widgets" class="headerlink" title="常用布局widgets"></a>常用布局widgets</h2><h3 id="标准widgets"><a href="#标准widgets" class="headerlink" title="标准widgets"></a>标准widgets</h3><blockquote>
<p><a href="https://api.flutter.dev/flutter/widgets/widgets-library.html" target="_blank" rel="noopener"> widgets-library</a> 中的 widget</p>
</blockquote>
<h4 id="Container-1"><a href="#Container-1" class="headerlink" title="Container"></a>Container</h4><p>添加 padding, margins, borders, background color, 或将其他装饰添加到widget</p>
<h4 id="GridView"><a href="#GridView" class="headerlink" title="GridView"></a>GridView</h4><h4 id="ListView"><a href="#ListView" class="headerlink" title="ListView"></a>ListView</h4><h4 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h4>]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始的Flutter开发_sp:FirstApp</title>
    <url>/2020/05/04/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84Flutter%E5%BC%80%E5%8F%91-sp-FirstApp/</url>
    <content><![CDATA[<p>按照官方网站的教程，完成了一个Flutter App的编写。先将代码贴出，待学成后尝试分析代码</p>
<a id="more"></a>

<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:english_words/english_words.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() =&gt; runApp(MyApp());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="comment">// This widget is the root of your application.</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MaterialApp(</span><br><span class="line">      title: <span class="string">'Welcome to Flutter'</span>,</span><br><span class="line">      theme: <span class="keyword">new</span> ThemeData(</span><br><span class="line">        primaryColor: Colors.blue,</span><br><span class="line">      ),</span><br><span class="line">      home: <span class="keyword">new</span> RandomWords(),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomWordsState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">RandomWords</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> _suggestions = &lt;WordPair&gt;[];</span><br><span class="line">  <span class="keyword">final</span> _saved = <span class="keyword">new</span> <span class="built_in">Set</span>&lt;WordPair&gt;();</span><br><span class="line">  <span class="keyword">final</span> _biggerFont = <span class="keyword">const</span> TextStyle(fontSize: <span class="number">18.0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement build</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Scaffold(</span><br><span class="line">      appBar: <span class="keyword">new</span> AppBar(</span><br><span class="line">        title: <span class="keyword">new</span> Text(<span class="string">'Startup Name Generator'</span>),</span><br><span class="line">        actions: &lt;Widget&gt;[</span><br><span class="line">          <span class="keyword">new</span> IconButton(</span><br><span class="line">            icon: <span class="keyword">new</span> Icon(Icons.list),</span><br><span class="line">            onPressed: _pushSaved,</span><br><span class="line">          ),</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">      body: _buildSuggestions(),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Widget _buildSuggestions() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ListView.builder(</span><br><span class="line">      padding: <span class="keyword">const</span> EdgeInsets.all(<span class="number">16.0</span>),</span><br><span class="line">      itemBuilder: (context, i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i.isOdd) <span class="keyword">return</span> <span class="keyword">new</span> Divider();</span><br><span class="line">        <span class="keyword">final</span> index = i ~/ <span class="number">2</span>;<span class="comment">// i/2 向下取整</span></span><br><span class="line">        <span class="keyword">if</span>(index &gt;= _suggestions.length) &#123;</span><br><span class="line">          _suggestions.addAll(generateWordPairs().take(<span class="number">10</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _buildRow(_suggestions[index]);</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Widget _buildRow(WordPair pair) &#123;</span><br><span class="line">    <span class="keyword">final</span> alreadySaved = _saved.contains(pair);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ListTile(</span><br><span class="line">      title: <span class="keyword">new</span> Text(</span><br><span class="line">        pair.asPascalCase,</span><br><span class="line">        style: _biggerFont,</span><br><span class="line">      ),</span><br><span class="line">      trailing: <span class="keyword">new</span> Icon(</span><br><span class="line">        alreadySaved ? Icons.favorite : Icons.favorite_border,</span><br><span class="line">        color: alreadySaved ? Colors.red : <span class="keyword">null</span>,</span><br><span class="line">      ),</span><br><span class="line">      onTap: () &#123;</span><br><span class="line">        setState(() &#123;</span><br><span class="line">          <span class="keyword">if</span>(alreadySaved) &#123;</span><br><span class="line">            _saved.remove(pair);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _saved.add(pair);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">void</span> _pushSaved() &#123;</span><br><span class="line">    Navigator.of(context).push(</span><br><span class="line">      <span class="keyword">new</span> MaterialPageRoute(</span><br><span class="line">          builder: (context) &#123;</span><br><span class="line">            <span class="keyword">final</span> tiles = _saved.map(</span><br><span class="line">                (pair) &#123;</span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">new</span> ListTile(</span><br><span class="line">                    title: <span class="keyword">new</span> Text(</span><br><span class="line">                      pair.asPascalCase,</span><br><span class="line">                      style: _biggerFont,</span><br><span class="line">                    ),</span><br><span class="line">                  );</span><br><span class="line">                &#125;,</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">final</span> divided = ListTile</span><br><span class="line">            .divideTiles(</span><br><span class="line">              context: context,</span><br><span class="line">              tiles: tiles,</span><br><span class="line">            )</span><br><span class="line">            .toList();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Scaffold(</span><br><span class="line">              appBar: <span class="keyword">new</span> AppBar(</span><br><span class="line">                title: <span class="keyword">new</span> Text(<span class="string">'Saved Suggestions'</span>),</span><br><span class="line">              ),</span><br><span class="line">              body: <span class="keyword">new</span> ListView(children: divided,),</span><br><span class="line">            );</span><br><span class="line">          &#125;,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomWords</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  createState() =&gt; <span class="keyword">new</span> RandomWordsState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Hexo发布博客添加图片的方法</title>
    <url>/2020/05/05/%E4%BD%BF%E7%94%A8Hexo%E5%8F%91%E5%B8%83%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E5%9B%BE%E7%89%87%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>关于在博客中添加图片遇到的坑</p>
<a id="more"></a>
<h1 id="两种方法"><a href="#两种方法" class="headerlink" title="两种方法"></a>两种方法</h1><h2 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h2><p>网上大部分的教程都是这种方法，即使用<code>hexo-asset-image</code>插件</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>首先了解Markdown中插入图片的语法格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![alt](.&#x2F;path&#x2F;image.jpg)</span><br><span class="line">or</span><br><span class="line">![alt](path&#x2F;image.jpg)</span><br></pre></td></tr></table></figure>
<p>这里的路径是<strong>图片文件在电脑内保存的相对路径</strong>，<code>hexo-asset-image</code>插件的作用就是将图片添加到博客源文件中，并重新设置好路径。在发布时，图片也会上传至GitHub仓库，这时网页便可以从GitHub仓库中链接到图片。</p>
<blockquote>
<p>注意<strong>不要</strong>使用<strong>反斜杠</strong>来划分，虽然在某些 Markdown 编辑器中（比如Typora）使用反斜杠的路径会被识别，但是在网页中它似乎并不能正确解析路径——结果就是图片在本地编辑器中可以显示，但在网页中，无论是 <code>localhost</code>上的预览页面还是真正的博客页面中，都无法显示</p>
</blockquote>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>大致分为三步</p>
<h4 id="修改-congif-yml"><a href="#修改-congif-yml" class="headerlink" title="修改_congif.yml"></a>修改_congif.yml</h4><p>修改主页配置文件<code>_config.yml</code>中的选项</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">post_asset_folder: ture</span><br></pre></td></tr></table></figure>
<blockquote>
<p>该选项默认为<code>false</code>，修改为<code>true</code> </p>
</blockquote>
<h4 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h4><p>使用如下指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install https:&#x2F;&#x2F;github.com&#x2F;CodeFalling&#x2F;hexo-asset-image --save</span><br></pre></td></tr></table></figure>
<p>安装插件（0.0.5版本）<br><span style="color: red">注意：</span>不要使用<code>npm install hexo-asset-image --save</code>指令安装插件，该指令安装的是1.0.0版本的插件，该版本插件会导致图片加载不成功</p>
<h3 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h3><p>现在，在执行指令<code>hexo new postName</code>之后，不仅会生成一个postName.md的文件，还会在<code>_posts</code>文件夹中生成一个与博文同名的文件夹，用于存放这篇博文中需要引用的图片<br>在需要引用图片的地方，使用上文提到的语法插入图片即可</p>
<h2 id="使用图床外链"><a href="#使用图床外链" class="headerlink" title="使用图床外链"></a>使用图床外链</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>原理十分简单，先手动将图片上传至互联网，然后在文章中将图片链接进来</p>
<h3 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h3><p>使用方法今后补充</p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始的Flutter开发_Day1</title>
    <url>/2020/05/01/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84Flutter%E5%BC%80%E5%8F%91_Day1/</url>
    <content><![CDATA[<p>课设需要 + 个人兴趣，总之今天开始学习Flutter开发了<br>本章只讲解环境搭建和搭建中可能遇到的问题及其解决方法</p>
<a id="more"></a>

<h1 id="初见"><a href="#初见" class="headerlink" title="初见"></a>初见</h1><h2 id="了解Flutter"><a href="#了解Flutter" class="headerlink" title="了解Flutter"></a>了解Flutter</h2><blockquote>
<p>Flutter是谷歌的移动UI框架，可以快速在iOS和Android上构建高质量的原生用户界面。 Flutter可以与现有的代码一起工作。在全世界，Flutter正在被越来越多的开发者和组织使用，并且Flutter是完全免费、开源的<br>—— From <a href="https://flutterchina.club/" target="_blank" rel="noopener">Flutter中文网</a></p>
</blockquote>
<h2 id="在Windows上搭建Flutter开发环境"><a href="#在Windows上搭建Flutter开发环境" class="headerlink" title="在Windows上搭建Flutter开发环境"></a>在Windows上搭建Flutter开发环境</h2><h3 id="安装教程"><a href="#安装教程" class="headerlink" title="安装教程"></a>安装教程</h3><p><a href="https://flutterchina.club/setup-windows/" target="_blank" rel="noopener">点击这里</a>查看安装教程</p>
<h3 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h3><ul>
<li>Android Studio无法加载Plugins<br>  解决方法依照博文：<a href="https://blog.csdn.net/weixin_44325428/article/details/85336410?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1" target="_blank" rel="noopener">android studio 无法搜索插件、下载插件解决办法</a>（将pligins文件夹替换为2.x版本的，利用2.x版本依赖下载）</li>
</ul>
<ul>
<li>执行flutter doctor时报错<code>android license status unknown</code><br>  执行命令:  <figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">flutter doctor --android-licenses</span><br></pre></td></tr></table></figure>
  此时有可能再次报错：  <figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">	Exception <span class="keyword">in</span> thread "main" java.lang.NoClassDefFoundError: javax/xml/bind/annotation/XmlSchema</span><br><span class="line">        <span class="built_in">at</span> com.android.repository.api.SchemaModule$SchemaModuleVersion.&lt;init&gt;(SchemaModule.java:<span class="number">156</span>)</span><br><span class="line">        <span class="built_in">at</span> com.android.repository.api.SchemaModule.&lt;init&gt;(SchemaModule.java:<span class="number">75</span>)</span><br><span class="line">        <span class="built_in">at</span> com.android.sdklib.repository.AndroidSdkHandler.&lt;clinit&gt;(AndroidSdkHandler.java:<span class="number">81</span>)</span><br><span class="line">        <span class="built_in">at</span> com.android.sdklib.tool.sdkmanager.SdkManagerCli.main(SdkManagerCli.java:<span class="number">73</span>)</span><br><span class="line">        <span class="built_in">at</span> com.android.sdklib.tool.sdkmanager.SdkManagerCli.main(SdkManagerCli.java:<span class="number">48</span>)</span><br><span class="line">Caused by: java.lang.ClassNotFoundException: javax.xml.bind.annotation.XmlSchema</span><br><span class="line">        <span class="built_in">at</span> java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:<span class="number">583</span>)</span><br><span class="line">        <span class="built_in">at</span> java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:<span class="number">178</span>)</span><br><span class="line">        <span class="built_in">at</span> java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:<span class="number">521</span>)</span><br><span class="line">        ... <span class="number">5</span> <span class="built_in">more</span></span><br></pre></td></tr></table></figure>
  这是因为计算机中Java版本过高，高版本的Java删除了一些库导致它缺少依赖，网上一般有两种方法解决：<pre><code>1.降低jdk版本
首先，&lt;a href=&quot;https://www.oracle.com/java/technologies/javase-jdk8-downloads.html&quot;&gt;下载jdk8&lt;/a&gt;
下载完成后，安装jdk8，一般安装路径默认为`C:\Program     Files\Java`，也可以自行指定路径；
安装完毕后，**修改环境变量**，将`JAVA_HOME`修改为`C:\Program     Files\Java\jdk1.8.0_xxx`（或者是自定义的安装路径        `path\jdk1.8.0_xxx`）
在环境变量Path中把`%JAVA_HOME%\bin`移到最前
保存修改，打开CMD，输入指令：
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure>
查看Java版本是否修改成功；</code></pre></li>
</ul>
<pre><code>2.自己添加jaxb相关依赖
    参考：&lt;a href=&quot;https://www.wandouip.com/t5i325108/&quot;&gt;安装Flutter环境遇到Android license status unknown问题解决&lt;/a&gt;
    步骤比较繁琐，不想舍弃新版本Java特性的朋友可以试试看；



解决完Java版本问题之后，再次执行`flutter doctor`得到如下输出：
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">	octor summary (to see all details, run flutter doctor -v):</span><br><span class="line">[√] Flutter (Channel stable, v1.<span class="number">12</span>.<span class="number">13</span>+hotfix.<span class="number">9</span>, on Microsoft Windows [Version <span class="number">10</span>.<span class="number">0</span>.<span class="number">18362</span>.<span class="number">778</span>], locale zh-CN)</span><br><span class="line">[!] Android toolchain - develop <span class="keyword">for</span> Android devices (Android SDK version <span class="number">29</span>.<span class="number">0</span>.<span class="number">3</span>)</span><br><span class="line">    ! Some Android licenses <span class="keyword">not</span> accepted.  To resolve this, run: flutter doctor --android-licenses</span><br><span class="line">[√] Android Studio (version <span class="number">3</span>.<span class="number">5</span>)</span><br><span class="line">[!] Connected device</span><br><span class="line">    ! No devices available</span><br></pre></td></tr></table></figure>
可以看到`android license status unknown`的报错已经没有了，此时按照提示再次输入指令：
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">flutter doctor --android-licenses</span><br></pre></td></tr></table></figure>
得到输出：
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">Review licenses that have <span class="keyword">not</span> been accepted (y/N)?</span><br></pre></td></tr></table></figure>
输入`y`检查尚未接受的许可
当提示是否接受许可时，输入`y`进行确认
最终得到：
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">All SDK package licenses accepted</span><br></pre></td></tr></table></figure></code></pre><p>至此，Fultter的环境搭建就完成了</p>
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Hexo和GitHub搭建个人博客</title>
    <url>/2020/02/20/%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>这篇文章将介绍如何使用Hexo与GitHub搭建自己的博客</p>
<a id="more"></a>

<h1 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h1><h2 id="什么是Hexo"><a href="#什么是Hexo" class="headerlink" title="什么是Hexo"></a>什么是Hexo</h2><blockquote>
<p>Hexo 是一个快速、简洁且高效的博客框架。——From <a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/</a></p>
</blockquote>
<p>简单来说，使用Hexo可以方便地搭建和管理个人博客</p>
<h2 id="Hexo安装"><a href="#Hexo安装" class="headerlink" title="Hexo安装"></a>Hexo安装</h2><p>在安装Hexo之前，需要先安装 <a href="http://nodejs.cn/download/" target="_blank" rel="noopener" title="Node.js Download">Node.js</a> 和 <a href="https://www.git-scm.com/download/" target="_blank" rel="noopener" title="Git Download">Git</a> </p>
<h4 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h4><p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境，当然这不是重点。重点是Hexo需要使用npm安装，而Node.js使用npm作为包管理工具——所以我们安装Node.js是为了使用npm</p>
<h4 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h4><p>Git是一个开源的分布式版本控制系统，用于部署站点和更新内容</p>
<p>安装完成后，在命令行中输入以下代码来检查是否安装成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line">git --version</span><br></pre></td></tr></table></figure>

<p>若输出版本号(如下)，说明安装成功</p>
<p><img src="/2020/02/20/%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/cmdOut.png" alt="安装成功时的输出"></p>
<p>确认安装好 Node.js 之后，在<strong>命令行</strong>中输入以下代码来安装Hexo</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<h2 id="Hexo基本操作"><a href="#Hexo基本操作" class="headerlink" title="Hexo基本操作"></a>Hexo基本操作</h2><h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init [folder]</span><br></pre></td></tr></table></figure>
<p>新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站</p>
<h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>
<p>新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>-p, –path</td>
<td>自定义新文章的路径</td>
</tr>
<tr>
<td>-r, –replace</td>
<td>如果存在同名文章，将其替换</td>
</tr>
</tbody></table>
<h3 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">hexo g</span><br></pre></td></tr></table></figure>
<p>生成静态文件</p>
<h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo server</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<p>启动服务器。默认情况下，访问网址为： <code>http://localhost:4000/</code></p>
<h3 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo deploy</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>部署网站，<strong>需要先生成静态文件</strong></p>
<h3 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure>
<p>清除缓存文件和已经生成的静态文件</p>
<blockquote>
<p>在发现对站点的更改无法生效时，可以尝试执行该指令后重新部署</p>
</blockquote>
<h1 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h1><h2 id="初始化站点"><a href="#初始化站点" class="headerlink" title="初始化站点"></a>初始化站点</h2><p>安装完 Hexo 后，执行下列命令，Hexo将会在指定文件夹中新建所需要的文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init &lt;站点文件夹地址&gt;</span><br><span class="line">cd &lt;站点文件夹地址&gt;</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>
<p>或者你也可以在文件夹中新建一个空的站点文件夹，进入该文件夹后在空白处用<code>shift + 鼠标右键</code>打开快捷菜单栏，选择“在此处打开Powershell窗口”进入命令行工具，直接输入 <code>hexo init</code> 指令</p>
<h2 id="站点文件夹简介"><a href="#站点文件夹简介" class="headerlink" title="站点文件夹简介"></a>站点文件夹简介</h2><p>执行 <code>hexo init</code> 指令后，可以看到站点文件夹的构成如下</p>
<p><img src="/2020/02/20/%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/folderContents.png" alt="站点文件夹构成"></p>
<h3 id="scaffolds"><a href="#scaffolds" class="headerlink" title="scaffolds"></a>scaffolds</h3><p>模板文件夹。在新建文章时，Hexo 会根据 scaffold 来建立文件</p>
<blockquote>
<p>Hexo的模板是指在新建的文章文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改</p>
</blockquote>
<h3 id="source"><a href="#source" class="headerlink" title="source"></a>source</h3><p>资源文件夹。用于存放用户资源</p>
<blockquote>
<p>除<code>_posts</code>文件夹之外，开头命名为<code>_</code>(下划线)的文件/文件夹和隐藏的文件将会被忽略</p>
</blockquote>
<h3 id="themes"><a href="#themes" class="headerlink" title="themes"></a>themes</h3><p>主题文件夹。Hexo根据主题生成静态页面</p>
<h3 id="config-yml"><a href="#config-yml" class="headerlink" title="_config.yml"></a>_config.yml</h3><p>网站的配置信息，大部分的参数都在此配置</p>
<h3 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h3><p>应用程序的信息</p>
<h2 id="部署站点"><a href="#部署站点" class="headerlink" title="部署站点"></a>部署站点</h2><h3 id="GitHub-Pages服务"><a href="#GitHub-Pages服务" class="headerlink" title="GitHub Pages服务"></a>GitHub Pages服务</h3><p>Github Pages用于托管个人的静态网站，这是搭建个人博客的关键</p>
<p><strong>进行以下步骤前，你需要拥有一个GitHub账号</strong></p>
<h3 id="开启服务"><a href="#开启服务" class="headerlink" title="开启服务"></a>开启服务</h3><p>新建仓库，注意，该仓库<strong>必须</strong>命名为<code>username.github.io</code>，<code>username</code> 指你的GitHub账号，以该方式命名的仓库会开通GitHub Pages服务</p>
<h3 id="上传GitHub"><a href="#上传GitHub" class="headerlink" title="上传GitHub"></a>上传GitHub</h3><p>配置git</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config -global user.name</span><br><span class="line">git config -global user.email</span><br></pre></td></tr></table></figure>

<p>安装部署插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i hexo-deployer-git -S</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个插件用于将生成的静态文件部署到GitHub的仓库中去</p>
</blockquote>
<p>配置<code>_config.yml</code>文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy</span><br><span class="line">    type: git</span><br><span class="line">    repo: https:&#x2F;&#x2F;github.com&#x2F;username&#x2F;username.github.io.git</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意“：”后面有空格</p>
</blockquote>
<p>生成静态文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>
<blockquote>
<p>是<code>hexo generate</code>的简写</p>
</blockquote>
<p>部署站点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<blockquote>
<p>是<code>hexo deploy</code>的简写</p>
</blockquote>
<h2 id="访问站点"><a href="#访问站点" class="headerlink" title="访问站点"></a>访问站点</h2><p>部署完成后，可以在 <a href="https://username.github.io/" target="_blank" rel="noopener">https://username.github.io/</a> 上访问到自己的网页</p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>体系结构复习</title>
    <url>/2020/06/20/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<p>计算机体系结构复习笔记</p>
<a id="more"></a>
<h1 id="1-体系结构的基本概念"><a href="#1-体系结构的基本概念" class="headerlink" title="1-体系结构的基本概念"></a>1-体系结构的基本概念</h1><h2 id="计算机体系结构的基本概念"><a href="#计算机体系结构的基本概念" class="headerlink" title="计算机体系结构的基本概念"></a>计算机体系结构的基本概念</h2><h3 id="计算机系统中的层次概念"><a href="#计算机系统中的层次概念" class="headerlink" title="计算机系统中的层次概念"></a>计算机系统中的层次概念</h3><p>层次由低到高排序</p>
<ul>
<li>M0：微程序机器级，该级的机器语言为<em>微指令集</em>，微指令编写的微程序一般直接由硬件解释实现</li>
<li>M1：传统机器级，该级的机器语言为<strong>该机器</strong>上的指令集</li>
<li>M2：<strong>操作系统</strong>虚拟机，是<strong>计算机软硬件的交界面</strong>，此层次之下为硬件层次，此层次之上为软件层次</li>
<li>M3：<strong>汇编语言</strong>虚拟机，该级的机器语言为汇编语言，<blockquote>
<p>M0、M1、M2通常使用<strong>解释</strong>(interpretation)的方法实现，而M3及以上的层次通常使用<strong>翻译</strong>(translation)实现</p>
</blockquote>
</li>
<li>M4：<strong>高级语言</strong>虚拟机，该级的机器语言是各种高级语言，高级语言的翻译过程即为<strong>编译</strong>(compile)</li>
<li>M5：<strong>应用语言</strong>虚拟机，为是计算机满足某种特殊需求而专门设计</li>
</ul>
<h3 id="计算机体系结构"><a href="#计算机体系结构" class="headerlink" title="计算机体系结构"></a>计算机体系结构</h3><p><em><em>定义：（机器语言的）程序员所看到的计算机的属性，即</em>概念性结构<em>与</em>功能特性</em> **</p>
<blockquote>
<p>该定义由 Amdahl 提出<br>所谓的“属性”是指</p>
<ul>
<li>数据表示</li>
<li>寻址规则</li>
<li>寄存器定义</li>
<li>指令集</li>
<li>中断系统</li>
<li>机器工作状态的定义和切换</li>
<li>存储系统</li>
<li>信息保护</li>
<li>I/O结构</li>
</ul>
</blockquote>
<p><strong>广义定义</strong>：</p>
<ul>
<li>指令集架构</li>
<li>计算机组织——计算机系统的逻辑实现</li>
<li>计算机实现——计算机系统的物理实现</li>
</ul>
<h3 id="计算机组织和计算机实现技术"><a href="#计算机组织和计算机实现技术" class="headerlink" title="计算机组织和计算机实现技术"></a>计算机组织和计算机实现技术</h3><p>计算机组成：计算机系统的<strong>逻辑实现</strong></p>
<ul>
<li>包含物理机器级中的数据流和控制流的组成以及逻辑设计</li>
<li>着眼于：物理机器级内各事件的排序方式、控制方式以及各部件之间的联系</li>
</ul>
<p>计算机实现：计算机系统的<strong>物理实现</strong></p>
<ul>
<li>包含处理机、主存等部件的物理结构，器件的集成度和速度，模块、插件、底板的划分与连接等</li>
<li>着眼于：器件技术、微组装技术</li>
</ul>
<p><strong>一种体系结构可以有多种组成，一种组成可以有多种物理实现</strong></p>
<h2 id="定量分析技术"><a href="#定量分析技术" class="headerlink" title="定量分析技术"></a>定量分析技术</h2><p>用于衡量计算机性能的方法</p>
<h3 id="性能评测"><a href="#性能评测" class="headerlink" title="性能评测"></a>性能评测</h3><blockquote>
<p>性能之比是响应时间的反比</p>
</blockquote>
<p>性能x / 性能y = 响应时间y / 响应时间x</p>
<h3 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h3><p>用于测试计算机性能的程序:</p>
<ol>
<li>实际应用程序: 最可靠的方法</li>
<li>修正的(脚本化的)程序: 通过修正实际应用程序的<strong>部分代码</strong>或通过<strong>脚本描述</strong>来模拟实际应用</li>
<li>核心测试程序: 真实程序中提取的较短但很关键的代码</li>
<li>小测试程序: 几十行的, 具有特定目的的代码</li>
<li>合成测试程序: 基本思想与设计核心测试程序相同</li>
</ol>
<p>实际应用上，使用<strong>Benchmark Suites</strong>（测试程序组件）来测试机器性能，它是一组各方面都具有代表性的测试程序</p>
<blockquote>
<p>常见的如 SPEC</p>
</blockquote>
<h3 id="性能设计和评测的基本原则"><a href="#性能设计和评测的基本原则" class="headerlink" title="性能设计和评测的基本原则"></a>性能设计和评测的基本原则</h3><ol>
<li><p>大概率事件优先<br>最重要和最常用的原则: 对于大概率事件,赋予它优先的<strong>处理权</strong>和<strong>资源使用权</strong></p>
</li>
<li><p>Amdahl 定律<br>加快某部件执行速度所获得的<em>系统性能</em>加速比, 受限于<strong>该部件在系统中所占的重要性</strong><br><img src="/2020/06/20/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0/Amdahl.jpg" alt="Amdahl"></p>
</li>
<li><p>程序的局部性原理</p>
<ul>
<li>时间局部性</li>
<li>空间局部性</li>
</ul>
</li>
</ol>
<h3 id="CPU的性能"><a href="#CPU的性能" class="headerlink" title="CPU的性能"></a>CPU的性能</h3><p>CPU时间 = 总时钟周期数 / 时钟频率<br>CPI = 总时钟周期数 / IC</p>
<p>总CPU时间 = CPI * IC / 时钟频率</p>
<blockquote>
<p>时钟频率: 反映了计算机实现技术\生产工艺和计算机组织<br>CPI: 反映了计算机实现技术\计算机指令集的结构和计算机组织<br>IC: 指令条数, 反映了计算机指令集的结构和编译技术</p>
</blockquote>
<p>多组数据综合比较性能时，使用平均值（Mean）：</p>
<ul>
<li>Use AM(Arithmetic Mean) for times;</li>
<li>Use HM(Harmonic Mean) for rates; </li>
<li>Use GM(Geometric Mean) for ratios;</li>
<li><strong>Best of all, use unnormalized numbers to compute time</strong></li>
</ul>
<h1 id="2-指令集结构-ISA"><a href="#2-指令集结构-ISA" class="headerlink" title="2-指令集结构-ISA"></a>2-指令集结构-ISA</h1><h2 id="指令集是软件和硬件的接口"><a href="#指令集是软件和硬件的接口" class="headerlink" title="指令集是软件和硬件的接口"></a>指令集是软件和硬件的接口</h2><ul>
<li>功能定义：指令集实现的功能</li>
<li>精确描述：上层程序如何调用这些功能<br>ISA 只定义功能，不关心功能如何实现（功能的实现依靠微指令架构）</li>
</ul>
<h2 id="冯氏模型"><a href="#冯氏模型" class="headerlink" title="冯氏模型"></a>冯氏模型</h2><p>大部分现代 ISA 遵循的模型</p>
<h3 id="关键——Program-Counter-PC"><a href="#关键——Program-Counter-PC" class="headerlink" title="关键——Program Counter(PC)"></a>关键——Program Counter(PC)</h3><p>PC 决定了指令的执行顺序；<br>执行顺序和存储机构决定指令能否正确执行</p>
<h2 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h2><h3 id="长度"><a href="#长度" class="headerlink" title="长度"></a>长度</h3><ol>
<li>固定长度：代码密度(Code Density)低</li>
<li>可变长度：代码密度高</li>
<li>以上两种方法的折中：使用两种长度<blockquote>
<p>代码密度：同样的一段代码在编译之后占用的空间，<strong>占用空间越小，代码密度越高</strong></p>
</blockquote>
</li>
</ol>
<h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><ul>
<li>简单的编码可以简化译码器的实现</li>
<li>复杂的编码可以提高代码密度</li>
</ul>
<h3 id="MIPS指令格式"><a href="#MIPS指令格式" class="headerlink" title="MIPS指令格式"></a>MIPS指令格式</h3><blockquote>
<p>以 MIPS32 为例</p>
</blockquote>
<h4 id="长度-1"><a href="#长度-1" class="headerlink" title="长度"></a>长度</h4><p>32 bits</p>
<h4 id="编码-1"><a href="#编码-1" class="headerlink" title="编码"></a>编码</h4><p>三种格式， 简单编码<br><img src="/2020/06/20/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0/MIPS32-1.jpg" alt="format"></p>
<ul>
<li><p>R-Type：寄存器类型<br> Op(6)：6位操作码<br> Rs(5)：源寄存器编号<br> Rt(5)：源寄存器编号<br> Rd(5)：目标寄存器编号<br> Sh(5)：移位的位数（在移位操作时用）<br> Func(6)：功能码</p>
<blockquote>
<p>指令的功能由操作码和功能码共同决定</p>
</blockquote>
</li>
<li><p>I-Type：立即数类型<br> Op(6)：6位操作码<br> Rs(5)：源寄存器编号<br> Rt(5)：目标寄存器编号<br> Immed(16)：立即数</p>
</li>
<li><p>J-Type：跳转类型<br> Op(6)：6位操作码<br> Target(26)：跳转目标<br> <strong>无条件跳转</strong><br> New PC = { (PC + 4)[31..28], Target, 2’b00}</p>
<blockquote>
<p>将PC + 4的高四位与 Target 值合并，末位补2个0 <em>(4 + 26 + 2 = 32)</em></p>
</blockquote>
</li>
</ul>
<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p>操作类型由操作码编码<br>More operation types <strong>!=</strong> Better ISA</p>
<h3 id="操作数模型"><a href="#操作数模型" class="headerlink" title="操作数模型"></a>操作数模型</h3><blockquote>
<p>以完成功能 <em>A = B + C</em> 为例</p>
</blockquote>
<ol>
<li><p><strong>Memory Only</strong><br>add A, B, C        ;mem[A] = mem[B] + mem[C]<br><img src="/2020/06/20/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0/MemOnly.jpg" alt="format"></p>
</li>
<li><p><strong>Accumulator</strong><br>load B          ;ACC = mem[B]<br>add C           ;ACC = ACC + mem[C]<br>store A         ;mem[A] = ACC<br><img src="/2020/06/20/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0/Acc.jpg" alt="format"></p>
</li>
<li><p><strong>Stack</strong><br>push B<br>push C<br>add<br>pop A<br><img src="/2020/06/20/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0/Stack.jpg" alt="format"></p>
</li>
<li><p><strong>Registers</strong></p>
<ul>
<li><p>通用寄存器类型<br>load R1, B<br>add R1, C<br>store R1, A</p>
</li>
<li><p>Load-store 类型<em>（只能通过load/store指令访存）</em><br>load R1, B<br>load R2, C<br>add R1, R1, R2<br>store R1, A<br><img src="/2020/06/20/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0/Regs.jpg" alt="format"></p>
</li>
</ul>
<h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><ul>
<li>static code size：程序对应的机器指令数<br>指令数：load-store &gt; register &gt; memory only</li>
<li>data memory traffic：访存次数<br>访存次数：load-store &lt; register &lt; memory only</li>
<li>instruction latency：指令延迟<br>延迟时间：load-store &lt; register &lt; memory only</li>
</ul>
<h4 id="寻址模式"><a href="#寻址模式" class="headerlink" title="寻址模式"></a>寻址模式</h4><p>MIPS只支持 <strong>寄存器基址 + 立即数偏移量</strong> 的寻址方式<br>原因：80/20法则</p>
</li>
</ol>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h2 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h2><p><img src="/2020/06/20/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0/chap2-branch.jpg" alt="branch"></p>
<h1 id="3-流水线技术"><a href="#3-流水线技术" class="headerlink" title="3-流水线技术"></a>3-流水线技术</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>将一重复的时序过程分解为若干子过程，每个子过程都有可能有效地在其<strong>专用功能段</strong>上与其他子过程<strong>同时执行</strong>，这种技术称为流水技术</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>在不缩短单个任务响应时间的情况下，提高系统吞吐率</li>
<li>流水线速度受限于<strong>最慢流水段</strong>的速度，故各流水段时间应该尽量相等，通常为1个时间周期</li>
<li>流水线需要经过一定的时间才能稳定（即流水线的<em>填充</em>）</li>
<li>流水线中多任务并行处理</li>
<li>最大加速比 = 流水段数</li>
<li>流水技术适合于大量重复的时序过程<blockquote>
<p>流水段数也叫流水深度；<br>流水线一般<strong>不能</strong>达到最大加速比，原因如下：</p>
<ol>
<li>流水段速度不匹配</li>
<li>流水线的<em>填充<em>和</em>排空</em></li>
</ol>
</blockquote>
</li>
</ul>
<h3 id="MIPS-中的流水线"><a href="#MIPS-中的流水线" class="headerlink" title="MIPS 中的流水线"></a>MIPS 中的流水线</h3><ul>
<li>五段流水：IF、ID、EX、MEM、WB</li>
</ul>
<h3 id="时空图"><a href="#时空图" class="headerlink" title="时空图"></a>时空图</h3><p>流水线的表示方式，从时间和空间两方面描述流水线工作过程</p>
<ul>
<li>横坐标表示<em>时间</em></li>
<li>纵坐标表示<em>各流水段</em></li>
</ul>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="1-单功能-多功能流水线"><a href="#1-单功能-多功能流水线" class="headerlink" title="1.单功能/多功能流水线"></a>1.单功能/多功能流水线</h4><p>单功能流水线：只能完成一种固定功能的流水线<br>多功能流水线：各段可以进行不同的连接，从而实现不同的功能</p>
<h4 id="2-静态-动态流水线"><a href="#2-静态-动态流水线" class="headerlink" title="2.静态/动态流水线"></a>2.静态/动态流水线</h4><blockquote>
<p><strong>针对多功能流水线而言</strong></p>
</blockquote>
<p>静态流水线：在某段时间间隔内，流水线各段只能按<strong>同一种</strong>功能的连接方式工作<br>动态流水线：在某段时间间隔内，流水线的一些段实现某种运算时，另一些段在实现另一种运算</p>
<h4 id="3-部件级-处理机级-处理机间流水线"><a href="#3-部件级-处理机级-处理机间流水线" class="headerlink" title="3.部件级/处理机级/处理机间流水线"></a>3.部件级/处理机级/处理机间流水线</h4><p>部件级流水线：运算操作流水线，将处理机的算术逻辑部件分段<br>处理机级流水线：<strong>指令流水线</strong>，将解释指令的过程按照流水方式处理<br>处理机间流水线：宏流水线，多处理机串行地对同一数据流进行处理</p>
<h4 id="4-标量-向量流水处理机"><a href="#4-标量-向量流水处理机" class="headerlink" title="4.标量/向量流水处理机"></a>4.标量/向量流水处理机</h4><p>标量流水处理机：处理机不具有向量数据表示，仅对标量数据进行流水处理<br>向量流水处理机：处理机具有向量数据表示，并通过向量指令对向量个元素进行处理</p>
<h4 id="5-线性-非线性流水线"><a href="#5-线性-非线性流水线" class="headerlink" title="5.线性/非线性流水线"></a>5.线性/非线性流水线</h4><p>线性流水线：流水线各段串行连接，没有回路<br>非线性流水线：流水线中存在反馈回路，存在流水线调度问题</p>
<h4 id="6-顺序-乱序流水线"><a href="#6-顺序-乱序流水线" class="headerlink" title="6.顺序/乱序流水线"></a>6.顺序/乱序流水线</h4><p>按<em>输出端任务流出顺序</em>与<em>输入端任务流入顺序</em>是否相同划分</p>
<h2 id="流水线性能分析"><a href="#流水线性能分析" class="headerlink" title="流水线性能分析"></a>流水线性能分析</h2><h3 id="吞吐率"><a href="#吞吐率" class="headerlink" title="吞吐率"></a>吞吐率</h3><p>单位时间内流水线完成的任务数（指令数）</p>
<ul>
<li><p>最大吞吐率TP<sub>max</sub>：流水线达到稳定状态后的吞吐率</p>
<blockquote>
<p>稳定状态：流水线各段都处于忙碌状态</p>
</blockquote>
</li>
<li><p>若流水线各段时间相等，均为Δt0，则有：<br> <em>TP<sub>max</sub> = 1 / Δt0</em></p>
</li>
<li><p>若各段时间不等，为Δti，则有：<br> <em>TP<sub>max</sub> = 1 / max(Δti)</em></p>
</li>
</ul>
<p>最慢的流水段成为流水线的<em>瓶颈</em>；<br>消除流水线瓶颈的方法：<br><img src="/2020/06/20/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0/%E6%B6%88%E9%99%A4%E7%93%B6%E9%A2%88.jpg" alt="消除瓶颈"></p>
<ul>
<li>细分瓶颈段</li>
<li>重复设置瓶颈段后的流水线</li>
</ul>
<ul>
<li>实际吞吐率TP<blockquote>
<p>流水段数m，任务数n，各段耗时相等，为Δt0</p>
</blockquote>
</li>
</ul>
<p><img src="/2020/06/20/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0/chap3-TP.jpg" alt="TP"><br>可知：</p>
<ul>
<li>TP &lt; TP<sub>max</sub></li>
<li>当<em> n &gt;&gt; m </em>时，TP ≈ TP<sub>max</sub></li>
</ul>
<p><strong>各段时间不等</strong>时，TP如下：<br><img src="/2020/06/20/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0/chap3-T%E6%B5%81%E6%B0%B4.jpg" alt="TP"><br><img src="/2020/06/20/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0/chap3-TP2.jpg" alt="TP"></p>
<h3 id="加速比"><a href="#加速比" class="headerlink" title="加速比"></a>加速比</h3><p>流水线速度与<strong>等功能</strong>的非流水线的速度之比<br><em>S = T非流水 / T流水</em><br>令流水段数 m，任务数 n</p>
<ul>
<li>各段时间相等，为 Δt0，则：<br> T非流水 = n×m×Δt0<br> T流水 = m×Δt0 + (n-1)×Δt0<br> S = m / (1 + (m - 1) /n)<blockquote>
<p>该加速比公式体现<strong>段数决定最大加速比</strong></p>
</blockquote>
</li>
</ul>
<h3 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h3><p>流水线的设备利用率 <em>E</em><br>由于流水线有填充和排空时间，故<strong>必然有</strong> E &lt; 1<br>若各段时间相等，则各段效率也相等：E1 = E2 = … = （nΔt0）/ T流水</p>
<p>泛用的效率计算公式： E = n 个任务占用的时空区面积 / m 个段总的时空区面积</p>
<h2 id="流水线中的相关"><a href="#流水线中的相关" class="headerlink" title="流水线中的相关"></a>流水线中的相关</h2><h3 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h3><ul>
<li>结构相关：硬件资源的冲突</li>
<li>数据相关：一条指令要<strong>用到前面指令的执行结果</strong>，而这些指令在流水线中重叠执行时，可能引起数据相关</li>
<li>控制相关：流水线遇到会<strong>改变 PC 的值</strong>的指令时会发生控制相关<blockquote>
<p>相关的出现会导致流水线性能收到影响，甚至<strong>导致错误的执行结果</strong><br>消除相关的基本方法是让流水线<strong>暂停(Stall)</strong>某些指令，而继续执行其他一些指令</p>
</blockquote>
</li>
</ul>
<h3 id="结构相关"><a href="#结构相关" class="headerlink" title="结构相关"></a>结构相关</h3><p>解决方法：</p>
<ul>
<li>增加冗余的硬件资源</li>
<li>部件流水化</li>
<li>使用算法对资源请求进行排队（无法提高效率）</li>
</ul>
<h3 id="数据相关"><a href="#数据相关" class="headerlink" title="数据相关"></a>数据相关</h3><h4 id="分类-2"><a href="#分类-2" class="headerlink" title="分类"></a>分类</h4><ul>
<li>真相关/流相关：RAW(Read After Write)，即写后读相关</li>
<li>输出相关：WAW(Write After Write)，写后写相关</li>
<li>反相关：WAR(Write After Read)，读后写相关</li>
</ul>
<h4 id="真相关的消除"><a href="#真相关的消除" class="headerlink" title="真相关的消除"></a>真相关的消除</h4><h5 id="检测-等待"><a href="#检测-等待" class="headerlink" title="检测-等待"></a>检测-等待</h5><ul>
<li>只要检测到真相关，就插入暂停周期</li>
<li>实现简单，但效率低</li>
</ul>
<p><strong>硬件实现-Scoreboarding</strong></p>
<blockquote>
<p>与后文提到的“计分板算法”不是同一概念</p>
</blockquote>
<ol>
<li>每个寄存器都附加 1bit <strong>有效位</strong></li>
<li>当一个指令正在写某个寄存器时，将该寄存器的有效位<strong>置零</strong></li>
<li>处于<strong>译码阶段</strong>的指令需要先检测该指令的源寄存器和目标寄存器的有效位，若其中<strong>任何一个</strong>寄存器的有效位为 0 ，则暂停<br>该方法会检测到所有数据相关并暂停（反相关和输出相关也会导致暂停）</li>
</ol>
<p><strong>硬件实现2-基于组合逻辑的相关检测</strong></p>
<ol>
<li>记录处于<strong>译码阶段</strong>的指令的源寄存器，检测处于<strong>后续阶段</strong>（<em>执行、访存、写回阶段</em>）的指令是否要<strong>写</strong>上述被记录的寄存器</li>
<li>若有，则暂停<br>该方法下，只有<strong>真相关</strong>会导致暂停</li>
</ol>
<h5 id="定向技术"><a href="#定向技术" class="headerlink" title="定向技术"></a>定向技术</h5><p>上述方法只要检测到相关就立即插入暂停周期，但是我们想尽量减少插入的暂停——只在必要的时候暂停，定向技术就可以减少插入的暂停<br>基本思想：将计算结果从其产生的地方直接送至其它指令需要的地方（即不需前一个指令将结果写回寄存器后，另一指令再从该寄存器读出数据）<br>作用：尽量避免<strong>真相关</strong>引起的暂停</p>
<h5 id="需要暂停的相关"><a href="#需要暂停的相关" class="headerlink" title="需要暂停的相关"></a>需要暂停的相关</h5><p><strong>并不是所有真相关带来的暂停都可以采用定向技术来消除</strong><br>如，若有如下指令序列：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LW R1, 0(R2)</span><br><span class="line">SUB R4, R1, R5</span><br><span class="line">AND R6, R1, R7</span><br><span class="line">OR R8, R1, R9</span><br></pre></td></tr></table></figure>
<p>考虑MIPS五段流水，可知<code>SUB R4, R1, R5</code>中断操作数<code>R1</code>依赖于上一条访存指令<code>LW R1, 0(R2)</code>， SUB 指令在 EX 段(第三阶段)开始时就需要 R1 的数据，而 LW 指令直到 MEM 段(第四阶段)结束才能取出值，即使采用定向技术也不能解决该数据相关问题；<br><img src="/2020/06/20/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0/chap3-%E5%AE%9A%E5%90%91.jpg" alt="定向"><br>解决办法：设置<em>“流水线互锁</em>，一旦检测到上述数据相关，则暂停 LW 指令之后的所有指令，<strong>直到能够通过定向技术解决该数据相关</strong></p>
<h5 id="检测-消除"><a href="#检测-消除" class="headerlink" title="检测-消除"></a>检测-消除</h5><p>即<em>指令调度</em></p>
<h4 id="输出相关和反相关的消除"><a href="#输出相关和反相关的消除" class="headerlink" title="输出相关和反相关的消除"></a>输出相关和反相关的消除</h4><ul>
<li>寄存器换名</li>
<li>规定写操作只在一个阶段统一执行，且指令<strong>按顺序执行</strong><blockquote>
<p>MIPS 流水的写回段(WB)就是统一进行写操作的阶段，因此<strong>非动态调度的 MIPS 中不存在输出相关和反相关</strong></p>
</blockquote>
</li>
</ul>
<h4 id="指令调度"><a href="#指令调度" class="headerlink" title="指令调度"></a>指令调度</h4><p>基本思想：在<strong>编译阶段</strong>改变执行代码的顺序，消除潜在的暂停<br>考虑如下表达式生成的代码序列：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; b + c;</span><br><span class="line">d &#x3D; e - f;</span><br></pre></td></tr></table></figure>
<p>一般而言，不进行指令调度的代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LW  R1, (b)</span><br><span class="line">LW  R2, (c)</span><br><span class="line">;(Stall)</span><br><span class="line">ADD  R3, R1, R2</span><br><span class="line">SW  (a), R3</span><br><span class="line">LW  R4, (e)</span><br><span class="line">LW  R5, (f)</span><br><span class="line">;(Stall)</span><br><span class="line">SUB  R6, R4, R5</span><br><span class="line">SW  (d), R6</span><br></pre></td></tr></table></figure>
<p>会在注释处产生暂停，而进行指令调度后，可以消除暂停：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LW  R1, (b)</span><br><span class="line">LW  R2, (c)</span><br><span class="line">LW  R4, (e)  ;避免ADD暂停</span><br><span class="line">ADD  R3, R1, R2</span><br><span class="line">LW  R5, (f)</span><br><span class="line">SW  (a), R3  ;避免SUB暂停</span><br><span class="line">SUB  R6, R4, R5</span><br><span class="line">SW  (d), R6</span><br></pre></td></tr></table></figure>

<h3 id="控制相关"><a href="#控制相关" class="headerlink" title="控制相关"></a>控制相关</h3><p>所有指令都与<strong>上一条指令</strong>控制相关</p>
<ul>
<li>若上一条指令是非控制流指令，则 PC = PC + 4</li>
<li>若上一条指令是非控制流指令，则 PC 的值取决于指令的执行结果</li>
<li>是否是控制流指令，在<em>译码阶段</em>结束后可以确定</li>
<li>控制流指令的跳转地址，在<em>执行阶段</em>结束后才能确定<blockquote>
<p>无条件跳转的子过程调用的跳转地址可以在译码阶段结束后确定</p>
</blockquote>
</li>
</ul>
<p><img src="/2020/06/20/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0/chap3-branch.jpg" alt="branch"></p>
<h4 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h4><ul>
<li>暂停</li>
<li>分支预测</li>
<li>分支延迟槽</li>
</ul>
<h1 id="4-指令级并行ILP"><a href="#4-指令级并行ILP" class="headerlink" title="4-指令级并行ILP"></a>4-指令级并行ILP</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>ILP：Instruction Level Parallelism<br>处理机利用流水线使指令重叠并行执行，以达到提高性能的目的</p>
<h3 id="流水线实际CPI"><a href="#流水线实际CPI" class="headerlink" title="流水线实际CPI"></a>流水线实际CPI</h3><blockquote>
<p>CPI：Cycles Per Instruction，平均每条指令需要的周期数<br>IPC：Instructions Per Cycle，平均每个周期处理的指令数</p>
</blockquote>
<p>CPI = 理想CPI + 各类停顿（结构、控制、数据冲突导致）<br><em>理想CPI</em> 是衡量流水线最高性能的一个指标</p>
<h3 id="基本程序块"><a href="#基本程序块" class="headerlink" title="基本程序块"></a>基本程序块</h3><ul>
<li>一段除了<em>入口</em>和<em>出口</em>以外不包含<strong>其他分支</strong>的代码段</li>
<li>程序平均 5 - 7 条指令就会有一个分支</li>
</ul>
<h3 id="循环级并行"><a href="#循环级并行" class="headerlink" title="循环级并行"></a>循环级并行</h3><ul>
<li>使一个循环中不同循环体并行执行</li>
<li>指令级并行研究重点</li>
<li>一般使用<strong>循环展开</strong>来实现</li>
</ul>
<h3 id="相关与冲突"><a href="#相关与冲突" class="headerlink" title="相关与冲突"></a>相关与冲突</h3><h4 id="区分"><a href="#区分" class="headerlink" title="区分"></a>区分</h4><p><strong>相关和冲突是两个不同的概念：</strong></p>
<ol>
<li>相关是<strong>指令之间的关系</strong>，属于程序的固有属性；</li>
<li>冲突是<strong>相关在流水线上的反映</strong>，具体一次相关在流水线上是否会产生冲突以及冲突会带来多长的停顿，要考虑流水线本身的属性；</li>
</ol>
<h4 id="解决相关"><a href="#解决相关" class="headerlink" title="解决相关"></a>解决相关</h4><ul>
<li>保持相关，但<strong>避免冲突</strong>；</li>
<li>通过代码变换<strong>消除相关</strong>；<blockquote>
<p>可以看到要消除相关必须要改变代码，说明相关是程序的固有属性</p>
</blockquote>
</li>
</ul>
<h4 id="保证程序正确执行必须保持的属性"><a href="#保证程序正确执行必须保持的属性" class="headerlink" title="保证程序正确执行必须保持的属性"></a>保证程序正确执行必须保持的属性</h4><ul>
<li>数据流：保持<strong>数据相关</strong>和<strong>控制相关</strong></li>
<li>异常行为：即改变指令执行顺序<strong>不能导致程序中发生新的异常</strong></li>
</ul>
<h2 id="动态调度"><a href="#动态调度" class="headerlink" title="动态调度"></a>动态调度</h2><h3 id="静态调度的概念"><a href="#静态调度的概念" class="headerlink" title="静态调度的概念"></a>静态调度的概念</h3><ul>
<li>基于<strong>编译器</strong>的调度，以减少相关和冲突</li>
<li>在<strong>编译阶段</strong>进行的代码调度和优化</li>
<li>通过将相关的指令<em>拉开距离</em>来<strong>减少</strong>可能产生的停顿</li>
</ul>
<h3 id="动态调度的概念"><a href="#动态调度的概念" class="headerlink" title="动态调度的概念"></a>动态调度的概念</h3><p>在程序的<strong>执行过程</strong>中，依靠<em>专门硬件</em>对代码进行调度，减少<strong>数据相关</strong>导致的停顿</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>能处理一些在编译时情况不明的相关（如涉及访存的相关）</li>
<li>提高可移植性，能够使本来面向某一流水线优化编译的代码在其它流水线上也能高效运行</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>硬件复杂性显著增加</li>
</ul>
<h3 id="乱序执行"><a href="#乱序执行" class="headerlink" title="乱序执行"></a>乱序执行</h3><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>将五段流水的<strong>译码阶段</strong>再分为两个阶段：</p>
<ol>
<li>流出（IS）：译码、检测是否有结构冲突</li>
<li>读操作数（RO）：等待数据冲突消除、读操作数</li>
</ol>
<h4 id="带来的问题"><a href="#带来的问题" class="headerlink" title="带来的问题"></a>带来的问题</h4><ul>
<li>出现新的数据冲突</li>
<li>导致多条指令同时处于执行当中</li>
<li>异常处理比较复杂</li>
</ul>
<h2 id="计分板算法"><a href="#计分板算法" class="headerlink" title="计分板算法"></a>计分板算法</h2><p>一种动态调度算法</p>
<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><h4 id="算法目标"><a href="#算法目标" class="headerlink" title="算法目标"></a>算法目标</h4><p><strong>资源充足时</strong>，尽可能早地执行没有数据阻塞的指令，达到<em>每个时钟周期执行一条指令</em></p>
<h4 id="对-WAR（反相关）的解决方案"><a href="#对-WAR（反相关）的解决方案" class="headerlink" title="对 WAR（反相关）的解决方案"></a>对 WAR（反相关）的解决方案</h4><ul>
<li>排队等待操作以及它们操作数的拷贝</li>
<li>只在读操作数段(RO)才读取寄存器</li>
</ul>
<h4 id="对-WAW（输出相关）的解决方案"><a href="#对-WAW（输出相关）的解决方案" class="headerlink" title="对 WAW（输出相关）的解决方案"></a>对 WAW（输出相关）的解决方案</h4><p>检测到冒险，插入等待周期</p>
<h4 id="对“多条指令同时处于执行当中”问题的解决"><a href="#对“多条指令同时处于执行当中”问题的解决" class="headerlink" title="对“多条指令同时处于执行当中”问题的解决"></a>对“多条指令同时处于执行当中”问题的解决</h4><ul>
<li>部件流水</li>
<li>冗余部件</li>
</ul>
<h3 id="计分板控制的四级"><a href="#计分板控制的四级" class="headerlink" title="计分板控制的四级"></a>计分板控制的四级</h3><h4 id="Issue"><a href="#Issue" class="headerlink" title="Issue"></a>Issue</h4><blockquote>
<p>流出段，实现<strong>指令译码</strong>和<strong>检测结构冒险</strong></p>
</blockquote>
<p>允许流出的条件：</p>
<ul>
<li>指令需要的功能单元当前可用（检测结构冒险）</li>
<li><strong>没有</strong>其它的活动指令拥有与该指令同样的<strong>目的寄存器</strong>（检测WAW）<blockquote>
<p><em>活动指令</em>：已经进入流水线并且尚未完成执行的指令</p>
</blockquote>
</li>
</ul>
<p>若不满足上述条件，则暂停指令流出，<span style="color:red">且该指令之后的指令也不能流出</span>，直到冲突消除</p>
<blockquote>
<p>保证指令<strong>按序流出</strong></p>
</blockquote>
<h4 id="Read-Operands"><a href="#Read-Operands" class="headerlink" title="Read Operands"></a>Read Operands</h4><blockquote>
<p>读操作数段，等待数据冲突消除、读操作数</p>
</blockquote>
<p>操作数<em>可用</em>的条件：</p>
<ul>
<li>先前的活动指令没有写该寄存器</li>
<li>对所需要的寄存器的<strong>写操作已经结束</strong></li>
</ul>
<p>若操作数可用，则允许读操作数</p>
<h4 id="Execution"><a href="#Execution" class="headerlink" title="Execution"></a>Execution</h4><blockquote>
<p>执行段，实现指令功能</p>
</blockquote>
<p>执行结束后，需要<strong>通知计分板</strong></p>
<h4 id="Write-Result"><a href="#Write-Result" class="headerlink" title="Write Result"></a>Write Result</h4><blockquote>
<p>写结果段</p>
</blockquote>
<p>功能部件完成执行后，计分板就检测是否有<strong>反相关</strong></p>
<ul>
<li>若检测出反相关，则暂停指令直到冲突消除</li>
<li>否则，允许写结果</li>
</ul>
<h3 id="计分板中需要记录的信息"><a href="#计分板中需要记录的信息" class="headerlink" title="计分板中需要记录的信息"></a>计分板中需要记录的信息</h3><h4 id="Instruction-Status"><a href="#Instruction-Status" class="headerlink" title="Instruction Status"></a>Instruction Status</h4><p>指令处于四段中的哪一段</p>
<h4 id="Functional-Unit-Status"><a href="#Functional-Unit-Status" class="headerlink" title="Functional Unit Status"></a>Functional Unit Status</h4><p>功能单元的状态</p>
<ul>
<li>Busy：该单元是否处于忙碌状态</li>
<li>Op：该单元当前执行的操作</li>
<li>Fi：使用该单元的指令的<strong>目标寄存器</strong></li>
<li>Fj, Fk：使用该单元的指令的<strong>源寄存器</strong>（源寄存器也可能只有一个）</li>
<li>Qj, Qk：表明源寄存器 Fj, Fk 的值依赖于哪个功能单元</li>
<li>Rj, Rk：标识 Fj, Fk 数据是否准备好</li>
</ul>
<h4 id="Register-Result-Status"><a href="#Register-Result-Status" class="headerlink" title="Register Result Status"></a>Register Result Status</h4><p>标识哪个功能单元的结果会写到哪个寄存器</p>
<h4 id="信息的登记"><a href="#信息的登记" class="headerlink" title="信息的登记"></a>信息的登记</h4><p>指令一旦流出，就需要在计分板上登记信息</p>
<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul>
<li>顺序流出，乱序执行</li>
<li>没有旁路硬件</li>
<li>指令调度局限于基本块内</li>
<li>功能部件少</li>
<li>对于结构冒险和WAR冒险都采取等待，性能不高</li>
</ul>
<h2 id="Tomasulo算法"><a href="#Tomasulo算法" class="headerlink" title="Tomasulo算法"></a>Tomasulo算法</h2><p>另一种动态调度算法</p>
<h3 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h3><h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><p>即使在<strong>没有特殊编译支持</strong>的情况下，也能取得高性能</p>
<h4 id="与计分板的对比"><a href="#与计分板的对比" class="headerlink" title="与计分板的对比"></a>与计分板的对比</h4><ul>
<li><p>计分板算法的控制、缓冲器集中于计分板，而 Tomasulo 算法的分布于部件</p>
<blockquote>
<p>功能部件缓冲器被称为<em>保留站 (reservation stations)</em>，用于存放未决的操作数</p>
</blockquote>
</li>
<li><p>计分板算法中，指令中的寄存器被数值代替，而 Tomasulo 算法中的寄存器被<strong>指向保留站的指针</strong>代替</p>
<blockquote>
<p>这一过程称为：寄存器换名<br><strong>可以消除 WAR、WAW 冒险</strong></p>
</blockquote>
</li>
<li><p>结果从保留站直通功能部件，无需通过寄存器，而是通过<em>公共数据总线 (Common Data Bus) <em>将结果</em></em>广播**到所有的功能部件</p>
</li>
<li><p>Load 和 Store 也具有保留站（即缓冲）</p>
</li>
</ul>
<h3 id="Tomasulo-算法的三个阶段"><a href="#Tomasulo-算法的三个阶段" class="headerlink" title="Tomasulo 算法的三个阶段"></a>Tomasulo 算法的三个阶段</h3><h4 id="Issue-1"><a href="#Issue-1" class="headerlink" title="Issue"></a>Issue</h4><blockquote>
<p>流出段</p>
</blockquote>
<p>发射的条件：<br>保留站空闲（无结构冒险）</p>
<p>发射时执行的动作：</p>
<ul>
<li>进行寄存器换名（若需要则进行，不需要则直接发射）</li>
<li>若有操作数已经准备就绪，则将其送入保留站</li>
</ul>
<h4 id="Execution-1"><a href="#Execution-1" class="headerlink" title="Execution"></a>Execution</h4><blockquote>
<p>执行段</p>
</blockquote>
<p>允许执行的条件：<br>操作数均就绪</p>
<p>若未就绪，则<strong>观测公共总线</strong>等待所需结果</p>
<h4 id="Write-Result-1"><a href="#Write-Result-1" class="headerlink" title="Write Result"></a>Write Result</h4><blockquote>
<p>写结果段</p>
</blockquote>
<ul>
<li>通过公共总线将结果写入到所有等待的部件</li>
<li>标记保留站可用（释放保留站）</li>
</ul>
<h3 id="公共数据总线"><a href="#公共数据总线" class="headerlink" title="公共数据总线"></a>公共数据总线</h3><h4 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h4><ul>
<li>数据</li>
<li>源<blockquote>
<p>64 位数据 + 4 位功能部件源地址</p>
</blockquote>
</li>
</ul>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ul>
<li>保留站监测公共数据总线，若与期望的功能部件匹配，则写入功能部件、开始执行</li>
<li>产生的结果进行广播</li>
</ul>
<h3 id="保留站的组成"><a href="#保留站的组成" class="headerlink" title="保留站的组成"></a>保留站的组成</h3><ul>
<li>Op：功能部件，完成具体的操作</li>
<li>Vj, Vk：源操作数的<strong>实际数值</strong></li>
<li>Qj, Qk：将产生源寄存器值（将写的值）的保留站</li>
<li>Busy：保留站或功能单元的状态</li>
<li>Register result status：指明那个功能部件将写到哪个寄存器</li>
</ul>
<blockquote>
<ul>
<li>存储缓冲器中的 V 域存放将要存储的结果</li>
<li>没有计分板中的 Ready 标志</li>
<li>若 Qj, Qk = null ，就表示操作数处于 Ready 状态</li>
</ul>
</blockquote>
<h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><ul>
<li>顺序发射、乱序执行、乱序完成</li>
<li>反相关和输出相关不会导致暂停</li>
<li>硬件复杂</li>
<li>需要大量高速的相联存储</li>
</ul>
<h2 id="动态分支预测"><a href="#动态分支预测" class="headerlink" title="动态分支预测"></a>动态分支预测</h2><p>在程序运行时，根据分支指令过去的表现来预测分支指令将来的行为</p>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h4 id="目的-1"><a href="#目的-1" class="headerlink" title="目的"></a>目的</h4><ul>
<li>预测分支是否成功</li>
<li>尽快找到分支目标地址，避免控制相关造成的停顿</li>
</ul>
<h4 id="需要解决的问题"><a href="#需要解决的问题" class="headerlink" title="需要解决的问题"></a>需要解决的问题</h4><ul>
<li>如何记录分支的历史信息</li>
<li>如何根据历史信息预测分支</li>
<li>预测错误时如何处理</li>
</ul>
<h3 id="BHT——分支历史表"><a href="#BHT——分支历史表" class="headerlink" title="BHT——分支历史表"></a>BHT——分支历史表</h3><p><em>Branch History Table</em></p>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><ul>
<li>最简单的动态分支预测方法</li>
<li>使用 BHT 来记录分支指令<strong>最近一次或几次</strong>的执行情况（是否成功），并据此预测</li>
</ul>
<h4 id="只有1个预测位的BHT"><a href="#只有1个预测位的BHT" class="headerlink" title="只有1个预测位的BHT"></a>只有1个预测位的BHT</h4><ul>
<li>只记录最近一次的分支，BHT 中只需要** 1 位二进制**</li>
</ul>
<h4 id="采用2位二进制记录历史"><a href="#采用2位二进制记录历史" class="headerlink" title="采用2位二进制记录历史"></a>采用2位二进制记录历史</h4><ul>
<li>预测准确度大大提高</li>
<li>两位分支预测与 n 位（n &gt; 2）分支预测性能相差不大</li>
<li>状态转换图<br><img src="/2020/06/20/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0/chap4-bht.jpg" alt="BHT"></li>
</ul>
<h4 id="两位分支预测的步骤"><a href="#两位分支预测的步骤" class="headerlink" title="两位分支预测的步骤"></a>两位分支预测的步骤</h4><ol>
<li>分支预测<ul>
<li>当分支指令到达译码段时，根据从 BHT 读出的信息进行分支预测</li>
<li>若预测正确，继续处理后续指令；否则作废已经预取和分析的指令，恢复现场，从另一条分支重新取指令</li>
</ul>
</li>
<li>修改 BHT 的状态</li>
</ol>
<h4 id="BHT-的适用情况"><a href="#BHT-的适用情况" class="headerlink" title="BHT 的适用情况"></a>BHT 的适用情况</h4><p>判断分支是否成功所需时间<strong>大于</strong>确定分支目标所需时间</p>
<blockquote>
<p>因为 BHT 不支持提供分支目标地址，做出预测之后仍要计算分支目标</p>
</blockquote>
<h3 id="BTB——分支目标缓冲器"><a href="#BTB——分支目标缓冲器" class="headerlink" title="BTB——分支目标缓冲器"></a>BTB——分支目标缓冲器</h3><p><em>Branch Target Buffer</em></p>
<h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><p>将分支开销降为 0</p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul>
<li>将分支成功的<strong>分支指令的地址</strong>和<strong>分支目标的地址</strong>都放入缓冲区保存，缓冲区以分支指令的地址作为标识</li>
<li>BTB 结构<br><img src="/2020/06/20/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0/chap4-btb.jpg" alt="BTB"></li>
<li>操作流程<br><img src="/2020/06/20/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0/chap4-btb2.jpg" alt="BHT"></li>
</ul>
<h3 id="前瞻执行"><a href="#前瞻执行" class="headerlink" title="前瞻执行"></a>前瞻执行</h3><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><ul>
<li>对分支指令的结果进行猜测，并假设猜测总是正确，然后按照猜测结果取指令、流出指令、执行指令</li>
<li>指令执行的结果<strong>不立即写回寄存器/存储器</strong>，而是先放入缓冲器<em>ROB(Re-Order Buffer)</em></li>
<li>待相应指令得到<strong>确认(Commit)</strong>，才将结果写入寄存器/存储器</li>
</ul>
<h4 id="对-Tomasulo-算法进行扩充，使之支持前瞻执行"><a href="#对-Tomasulo-算法进行扩充，使之支持前瞻执行" class="headerlink" title="对 Tomasulo 算法进行扩充，使之支持前瞻执行"></a>对 Tomasulo 算法进行扩充，使之支持前瞻执行</h4><h5 id="将算法的写结果段分成两段"><a href="#将算法的写结果段分成两段" class="headerlink" title="将算法的写结果段分成两段"></a>将算法的写结果段分成两段</h5><ol>
<li>写结果<ul>
<li>前瞻执行结果写入 ROB</li>
<li>通过 CDB 在指令之间传送结果，供需要的指令使用</li>
</ul>
</li>
<li>指令确认<ul>
<li>分支结果出来后，对相应指令的前瞻执行予以确认</li>
<li>若猜测正确，将 ROB 中的结果写入寄存器/存储器</li>
<li>若猜测错误，不予以确认，从正确的分支路径开始重新取指执行</li>
</ul>
</li>
</ol>
<p><strong>关键思想</strong>：允许指令乱序执行，但必须<strong>顺序确认</strong></p>
<h5 id="ROB-的组成"><a href="#ROB-的组成" class="headerlink" title="ROB 的组成"></a>ROB 的组成</h5><ul>
<li>指令类型</li>
<li>目标地址：指令执行结果要写入的目标寄存器号/存储单元地址</li>
<li>数据值：保存指令前瞻执行的结果</li>
<li>就绪字段：指出指令是否执行完成且数据已经就绪</li>
</ul>
<blockquote>
<p>前瞻执行下，Tomasulo 算法中保留站的<strong>换名功能由 ROB 实现</strong></p>
</blockquote>
<h5 id="指令执行步骤"><a href="#指令执行步骤" class="headerlink" title="指令执行步骤"></a>指令执行步骤</h5><ol>
<li>流出<ul>
<li>指令队列头部取指</li>
<li>若有空闲的保留站<strong>且</strong>有空闲的 ROB 项，则流出指令，相应信息填入保留站和 ROB 项</li>
</ul>
</li>
<li>执行<ul>
<li>操作数就绪后，执行指令</li>
<li>操作数未就绪，检测 CDB</li>
</ul>
</li>
<li>写结果<ul>
<li>结果产生后，将<strong>结果</strong>连同流出段分配的** ROB 项的编号*<em>一同放入 CDB，经 CDB *</em>写入 ROB **及其它需要结果的保留站</li>
<li>释放产生该结果的保留站</li>
<li>store 指令：若待写数据就绪，则写入 ROB，否则监测 CDB</li>
</ul>
</li>
<li>确认<ul>
<li>分支指令：预测错误的分支到达 ROB 队列头部时，*<em>清空 ROB *</em>，从分支指令的另一分支重新执行；当预测正确的分支到达 ROB 头部时，该指令执行完成；</li>
<li>其它指令：该指令到达 ROB 队列头部且结果已经就绪时，将结果写入目标寄存器（store指令则写入存储器），并从 ROB 中删除该指令</li>
</ul>
</li>
</ol>
<h2 id="多指令流出技术"><a href="#多指令流出技术" class="headerlink" title="多指令流出技术"></a>多指令流出技术</h2><p>一个时钟周期允许流出多条指令</p>
<h3 id="多流出处理机的两种基本风格"><a href="#多流出处理机的两种基本风格" class="headerlink" title="多流出处理机的两种基本风格"></a>多流出处理机的两种基本风格</h3><h4 id="超标量-Superscalar"><a href="#超标量-Superscalar" class="headerlink" title="超标量(Superscalar)"></a>超标量(Superscalar)</h4><ul>
<li>每个时钟周期流出指令条数<strong>不固定</strong>（但<strong>有上限</strong>）</li>
<li>流出上限为 n，则该处理机称为* n 流出*</li>
<li>可以通过编译器进行<strong>静态调度</strong>，也可以基于 Tomasulo 算法进行<strong>动态调度</strong></li>
</ul>
<h4 id="VLIW-EPIC"><a href="#VLIW-EPIC" class="headerlink" title="VLIW/EPIC"></a>VLIW/EPIC</h4><blockquote>
<p>Very Long Instruction Word：超长指令字</p>
</blockquote>
<ul>
<li>每个时钟周期流出指令条数<strong>固定</strong>，这些指令构成一条长指令或<em>指令包</em></li>
<li>指令包中，指令之间的并行性是显式的</li>
<li>指令调度由<strong>编译器</strong>静态完成</li>
</ul>
<h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><ul>
<li>Superscalar 对程序员透明</li>
<li>没有经过编译器针对超标量结构进行优化的代码也能运行</li>
</ul>
<h3 id="静态多流出技术"><a href="#静态多流出技术" class="headerlink" title="静态多流出技术"></a>静态多流出技术</h3><ul>
<li>典型<em>超标量</em>处理器中，每个时钟周期可以流出** 1 ~ 8 **条指令</li>
<li>指令<strong>按序流出</strong>，流出时进行冲突检测</li>
</ul>
<h4 id="流出时的冲突检测"><a href="#流出时的冲突检测" class="headerlink" title="流出时的冲突检测"></a>流出时的冲突检测</h4><ul>
<li>包内冲突检测：检测指令包中的结构冲突/数据冲突，选出初步判定可以流出的指令</li>
<li>检测所选出的指令与正在执行的指令是否有冲突</li>
</ul>
<h4 id="影响性能的因素"><a href="#影响性能的因素" class="headerlink" title="影响性能的因素"></a>影响性能的因素</h4><ul>
<li>load指令</li>
<li>分支延迟</li>
</ul>
<h3 id="动态多流出系统"><a href="#动态多流出系统" class="headerlink" title="动态多流出系统"></a>动态多流出系统</h3><h4 id="扩展-Tomasulo-算法以支持动态多流出"><a href="#扩展-Tomasulo-算法以支持动态多流出" class="headerlink" title="扩展 Tomasulo 算法以支持动态多流出"></a>扩展 Tomasulo 算法以支持动态多流出</h4><ul>
<li>每周期流出两条指令</li>
<li>一条整数指令，一条浮点指令</li>
<li>指令顺序流向保留站</li>
<li>将整数用的表与浮点用的表结构分开，分别进行处理</li>
</ul>
<h2 id="循环展开和指令调度"><a href="#循环展开和指令调度" class="headerlink" title="循环展开和指令调度"></a>循环展开和指令调度</h2><p>由编译器在编译阶段完成</p>
<h3 id="循环展开常用方法"><a href="#循环展开常用方法" class="headerlink" title="循环展开常用方法"></a>循环展开常用方法</h3><ul>
<li>指令调度</li>
<li>寄存器重命名</li>
</ul>
<h1 id="5-存储层次"><a href="#5-存储层次" class="headerlink" title="5-存储层次"></a>5-存储层次</h1><h2 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h2><h3 id="设计多级存储的原因"><a href="#设计多级存储的原因" class="headerlink" title="设计多级存储的原因"></a>设计多级存储的原因</h3><p>人们对于存储器<strong>“容量大、速度快、价格低”</strong>的3个要求是互相矛盾的：</p>
<ul>
<li>速度越快，每位价格越高</li>
<li>容量越大，每位价格越低</li>
<li>容量越大，速度越慢</li>
</ul>
<p>设计层次结构以<strong>缓解矛盾</strong></p>
<h3 id="层次结构"><a href="#层次结构" class="headerlink" title="层次结构"></a>层次结构</h3><ol>
<li>Register File——寄存器组</li>
<li>L1 cache——一级缓存</li>
<li>L2 cache——二级缓存</li>
<li>L3 cache——三级缓存</li>
<li>Main Memory——主存</li>
<li>Swap Disk——外存</li>
</ol>
<h3 id="性能参数"><a href="#性能参数" class="headerlink" title="性能参数"></a>性能参数</h3><blockquote>
<p>详见教材P174</p>
</blockquote>
<h4 id="平均访问时间"><a href="#平均访问时间" class="headerlink" title="平均访问时间"></a>平均访问时间</h4><p><img src="/2020/06/20/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%5Cchap5-TA.jpg" alt="TA"><br>H：命中率<br>T<sub>A1</sub>：命中时的访存时间，即<em>命中时间</em><br>T<sub>A2</sub>：访问下一级存储器的时间<br>T<sub>B</sub>：将信息从下一级存储器传输到上一级存储器的时间<br>T<sub>M</sub> = T<sub>A2</sub> + T<sub>B</sub>：失效开销</p>
<blockquote>
<p>失效时，要先访问下一级存储(T<sub>A2</sub>)，将信息传送到上一级存储(T<sub>B</sub>)，再从上一级存储将数据读入(T<sub>A1</sub>)</p>
</blockquote>
<h2 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h2><p>用于弥补 CPU 与主存在速度上的差距</p>
<h3 id="映象规则"><a href="#映象规则" class="headerlink" title="映象规则"></a>映象规则</h3><p>映象——主存块如何放置在 Cache 中</p>
<h4 id="全相联映象"><a href="#全相联映象" class="headerlink" title="全相联映象"></a>全相联映象</h4><ul>
<li>主存中<strong>任意一块</strong>可以放置在 Cache 中的<strong>任意</strong>一个位置</li>
</ul>
<h4 id="直接映象"><a href="#直接映象" class="headerlink" title="直接映象"></a>直接映象</h4><ul>
<li>主存中的每一个块只能被放置在 Cache 中<strong>唯一</strong>的一个位置</li>
<li>若 Cache 块数为 <em>M</em>，主存中的第 <em>i</em> 块将映射到 Cache 中的第 <em>j</em> 块，则有：** j = i mod M**</li>
</ul>
<h4 id="组相联映象"><a href="#组相联映象" class="headerlink" title="组相联映象"></a>组相联映象</h4><ul>
<li>主存中的每一个块只能被放置在 Cache 中<strong>唯一的一组</strong>中的<strong>任意一个位置</strong></li>
<li>若 Cache<strong>组数</strong>为 <em>G</em>，主存中的第 <em>i</em> 块将映射到 Cache 中的第 <em>k</em> 组，则有：** k = i mod G**</li>
</ul>
<h4 id="相联度"><a href="#相联度" class="headerlink" title="相联度"></a>相联度</h4><ul>
<li>主存中的一块可以映射到 Cache 中的块数</li>
<li>相联度越高，Cache 空间利用率就越高，块冲突概率就越低，故 Cache 失效率也越低</li>
<li>相联度的提高会导致 Cache 的实现变复杂，因而不是相联度越高越好</li>
</ul>
<h4 id="子块-subblock"><a href="#子块-subblock" class="headerlink" title="子块(subblock)"></a>子块(subblock)</h4><ul>
<li>将一个块划分为若干子块，每个子块分配一个有效位和脏位（污染位）</li>
<li>CPU 请求数据时可以不用传输一整个块，进一步减少传输时间</li>
<li>对于写回法 Cache，发生替换时可以不需要将整个块写回到下一级存储，而只写被修改过的子块，以节省带宽</li>
<li>会带来额外的复杂度</li>
</ul>
<h3 id="查找方法"><a href="#查找方法" class="headerlink" title="查找方法"></a>查找方法</h3><h4 id="侯选位置"><a href="#侯选位置" class="headerlink" title="侯选位置"></a>侯选位置</h4><p>对于一个有 M 块的 Cache 而言：</p>
<ul>
<li>直接映像的侯选位置为1</li>
<li>全相联映象的侯选位置为 M</li>
<li>n 路组相联映象的侯选位置为 n</li>
</ul>
<h4 id="并行查找实现"><a href="#并行查找实现" class="headerlink" title="并行查找实现"></a>并行查找实现</h4><ul>
<li>组相联存储器</li>
<li>单体多字存储器 + 比较器</li>
</ul>
<h4 id="地址组成"><a href="#地址组成" class="headerlink" title="地址组成"></a>地址组成</h4><p>{Tag, 索引(index), 块内地址(byte in block)}<br><strong>Tag</strong>：用于检查在 Cache 中找到的数据是否是所需要的数据；<br><strong>索引</strong>：Cache 组号；<br><strong>块内地址</strong>：块内地址；</p>
<blockquote>
<p>{Tag, 索引} 被称为<em>主存块地址</em></p>
<ul>
<li>对于全相联映象，因为相当于整个 Cache 只有一个组，故没有索引段，整个主存块地址均为Tag</li>
<li>对于直接映象，因为相当于每个块都是一个组，故索引即为** Cache 块号**</li>
</ul>
</blockquote>
<h4 id="查找步骤"><a href="#查找步骤" class="headerlink" title="查找步骤"></a>查找步骤</h4><ol>
<li>根据缓存配置确定地址划分</li>
<li>根据索引将组中的块<strong>全部取出</strong>，比较 Tag 段</li>
<li>若 Tag 段比较成功，说明命中，再检查有效位</li>
<li>若有效，则命中；否则缺失</li>
</ol>
<h3 id="替换算法"><a href="#替换算法" class="headerlink" title="替换算法"></a>替换算法</h3><h4 id="最佳替换-OPT"><a href="#最佳替换-OPT" class="headerlink" title="最佳替换(OPT)"></a>最佳替换(OPT)</h4><ul>
<li>替换在之后最长时间不会被使用的块</li>
<li>难以预测今后的块使用情况，因而仅具有理论价值</li>
</ul>
<h4 id="随机法-Random"><a href="#随机法-Random" class="headerlink" title="随机法(Random)"></a>随机法(Random)</h4><ul>
<li>实现简单</li>
<li>无法反映程序局部性原理，失效率比 FLU 高</li>
</ul>
<h4 id="先进先出-FIFO"><a href="#先进先出-FIFO" class="headerlink" title="先进先出(FIFO)"></a>先进先出(FIFO)</h4><ul>
<li>容易实现</li>
<li>无法正确反映局部性原理</li>
</ul>
<h4 id="最近最少用-FLU"><a href="#最近最少用-FLU" class="headerlink" title="最近最少用(FLU)"></a>最近最少用(FLU)</h4><ul>
<li>实现较困难，目前实际上不是选择最近最少用的块替换，而是选择<strong>最久未被访问</strong>的块被替换</li>
<li>失效率为三者最低</li>
</ul>
<h3 id="写策略"><a href="#写策略" class="headerlink" title="写策略"></a>写策略</h3><h4 id="写直达法-Write-Through"><a href="#写直达法-Write-Through" class="headerlink" title="写直达法(Write Through)"></a>写直达法(Write Through)</h4><ul>
<li>执行“写”操作时，不仅将信息写入 Cache 中相应的块，也写入下一级存储器</li>
<li>保证下一级存储器中数据总是最新的</li>
<li>实现简单</li>
</ul>
<h4 id="写回法-Write-Back"><a href="#写回法-Write-Back" class="headerlink" title="写回法(Write Back)"></a>写回法(Write Back)</h4><ul>
<li>执行“写”操作时，仅将信息写入 Cache 中相应的块，只有当该块被<strong>替换</strong>时，才被写回主存</li>
<li>需要设置<em>污染位</em></li>
<li>速度快，减少访存次数</li>
</ul>
<h4 id="写失效的解决方法"><a href="#写失效的解决方法" class="headerlink" title="写失效的解决方法"></a>写失效的解决方法</h4><blockquote>
<p>写失效：要写时，在 Cache 中没有找到对应块</p>
</blockquote>
<ul>
<li>按写分配：先从内存中现将该块调入到 Cache 中，然后将数据写入 Cache 中对应的位置</li>
<li>不按写分配：直接写入下一级存储，而不将相应的块调入 Cache</li>
</ul>
<blockquote>
<p>一般而言，写回法的 Cache 采用按写分配法；写直达法的 Cache 采用不按写分配法</p>
</blockquote>
<h3 id="Cache-性能分析"><a href="#Cache-性能分析" class="headerlink" title="Cache 性能分析"></a>Cache 性能分析</h3><h4 id="影响因素"><a href="#影响因素" class="headerlink" title="影响因素"></a>影响因素</h4><ol>
<li><p>缓存大小(Cache Size)</p>
<ul>
<li>缓存越大，冲突率越少（命中率提升），但<strong>命中时间会增加</strong></li>
<li>实际上，缓存容量达到<strong>工作集</strong>大小时，命中率的上升速度就变缓了</li>
</ul>
</li>
<li><p>块大小(Block Size)</p>
<ul>
<li>缓存块过小时，无法捕获程序的<strong>空间局部性</strong>；且每块都需要分配 tag 和有效位，<strong>空间利用率低</strong></li>
<li>缓存块过大时，块<strong>传输时间上升</strong>，耗费带宽；且块数变少，冲突率提升，导致<strong>命中率下降</strong></li>
</ul>
</li>
<li><p>相联度</p>
<ul>
<li>高相联度具有较低的缺失率，但会导致较高的命中时间</li>
</ul>
</li>
</ol>
<h4 id="计算公式"><a href="#计算公式" class="headerlink" title="计算公式"></a>计算公式</h4><p>平均访存时间 = 命中时间 + 缺失率 × 失效开销</p>
<h4 id="改进-Cache-性能"><a href="#改进-Cache-性能" class="headerlink" title="改进 Cache 性能"></a>改进 Cache 性能</h4><ul>
<li>降低失效率</li>
<li>减少失效开销</li>
<li>减少 Cache 命中时间</li>
</ul>
<h2 id="降低-Cache-失效率的方法"><a href="#降低-Cache-失效率的方法" class="headerlink" title="降低 Cache 失效率的方法"></a>降低 Cache 失效率的方法</h2><h3 id="失效分类"><a href="#失效分类" class="headerlink" title="失效分类"></a>失效分类</h3><ol>
<li>强制性失效(Compulsory Miss)：当<strong>第一次</strong>访问一个块时，该块不在 Cache 中，需要从下一级存储器中调入</li>
<li>容量失效(Capacity Miss)：程序执行所需的块<strong>不能全部调入</strong> Cache 中，则当某些块被替换后又重新被访问而发生缺失</li>
<li>冲突失效(Conflict Miss)：在<em>组相联</em>或<em>直接映象</em>的 Cache 中，若<strong>过多的块映象到同一组（块）</strong>，导致被替换的块又被重新访问而发生的缺失</li>
</ol>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><ol>
<li>减少强制性失效——预取技术，加大块容量</li>
<li>减少容量失效——多级缓存，改善替换算法</li>
<li>减少冲突失效——提高相联度，使用 Hash 算法使索引更加随机，使用 Victim Cache 暂时保存最近被替换的块</li>
</ol>
<h3 id="Victim-Cache"><a href="#Victim-Cache" class="headerlink" title="Victim Cache"></a>Victim Cache</h3><p>![victim cache](./体系结构复习/victim cache.jpg)<br>增加一个小容量 Cache （4~8个块），将刚刚被替换的块暂存于此<br>原理：</p>
<ul>
<li>直接相联的 Cache 冲突率很高</li>
<li>被替换出去的块很有可能被重新访问</li>
</ul>
<h3 id="Hashing"><a href="#Hashing" class="headerlink" title="Hashing"></a>Hashing</h3><ul>
<li>使用 Hash 算法生成索引，使块在 Cache 中的分布更加均匀，以<strong>降低冲突率</strong></li>
<li>实现更加复杂</li>
</ul>
<h3 id="伪相联-Cache"><a href="#伪相联-Cache" class="headerlink" title="伪相联 Cache"></a>伪相联 Cache</h3><blockquote>
<p>既能获得多路组相联的低失效率，又能保持直接映像的命中速度</p>
</blockquote>
<h4 id="访问步骤"><a href="#访问步骤" class="headerlink" title="访问步骤"></a>访问步骤</h4><ol>
<li>命中情况下，访问 Cache 的过程与直接映像 Cache 的过程相同</li>
<li>不命中时，在访问下一级存储器之前，<strong>先检查 Cache 的另一个块</strong></li>
<li>若匹配，则发生<em>伪命中</em>，否则，访问下一级存储</li>
</ol>
<h3 id="编译器优化"><a href="#编译器优化" class="headerlink" title="编译器优化"></a>编译器优化</h3><ul>
<li>重构数据访问特征</li>
<li>重构数据布局</li>
</ul>
<h2 id="减少-Cache-失效开销"><a href="#减少-Cache-失效开销" class="headerlink" title="减少 Cache 失效开销"></a>减少 Cache 失效开销</h2><h3 id="内存层级平行-MLP"><a href="#内存层级平行-MLP" class="headerlink" title="内存层级平行(MLP)"></a>内存层级平行(MLP)</h3><blockquote>
<p>Memory Level Parallelism</p>
</blockquote>
<ul>
<li>并行地服务多条访存请求</li>
<li>在替换时，尽量选择<strong>可以并行处理的块</strong>替换出去</li>
</ul>
<h3 id="非阻塞-Cache-技术"><a href="#非阻塞-Cache-技术" class="headerlink" title="非阻塞 Cache 技术"></a>非阻塞 Cache 技术</h3><ul>
<li>失效时<strong>仍然允许 CPU 进行其它的命中访问</strong></li>
<li>需要用一个特殊的寄存器MSHR(Miss Status Handling Registers，缺失状态寄存器)，来记录发生缺失的信息</li>
</ul>
<h2 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h2><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><h4 id="映象规则-1"><a href="#映象规则-1" class="headerlink" title="映象规则"></a>映象规则</h4><p>采用<strong>全相联</strong>映象</p>
<blockquote>
<p>因为失效时需要访问磁盘，<strong>失效开销巨大</strong>，应当尽量降低失效率，实验选择全相联映象<br>引入<em>页表</em>来降低查找延迟</p>
</blockquote>
<h4 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h4><ol>
<li>由虚页号（段号）查找页表（段表）</li>
<li>将虚页（段）号转换为物理页（段）号</li>
<li>与页（段）内偏移拼接形成物理地址</li>
</ol>
<h4 id="替换算法-1"><a href="#替换算法-1" class="headerlink" title="替换算法"></a>替换算法</h4><p>基本使用<strong>LRU</strong></p>
<blockquote>
<p>一般使用附加访问位 + 定时复位的方法筛选最近最少用的页</p>
</blockquote>
<h4 id="写策略-1"><a href="#写策略-1" class="headerlink" title="写策略"></a>写策略</h4><p>主存与磁盘的访问时间差距过大，故采用<strong>写回法</strong></p>
<h4 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h4><p>页表尺寸过大时，会占用过多内存，影响性能，此时可以采用多级页表</p>
<h3 id="快表-TLB"><a href="#快表-TLB" class="headerlink" title="快表 (TLB)"></a>快表 (TLB)</h3><p>通过页表查找页面时，需要<strong>两次访存</strong>，为了进一步优化查找，减少查找延迟而引入<em>快表</em></p>
<ul>
<li><strong>快表是一个硬件缓存，访问速度比访问内存快</strong></li>
<li>快表存放最近经常访问的页表项</li>
<li>进行地址变换时，先查快表</li>
<li>快表不命中时，再去访问内存的页表，并且将本次访问的页表项放入快表</li>
</ul>
<h1 id="6-I-O系统"><a href="#6-I-O系统" class="headerlink" title="6-I/O系统"></a>6-I/O系统</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><h3 id="重要性"><a href="#重要性" class="headerlink" title="重要性"></a>重要性</h3><p>是冯诺依曼架构的重要组成部分</p>
<h3 id="衡量指标"><a href="#衡量指标" class="headerlink" title="衡量指标"></a>衡量指标</h3><ul>
<li>响应时间</li>
<li>可靠性</li>
</ul>
<h3 id="谬论"><a href="#谬论" class="headerlink" title="谬论"></a>谬论</h3><p>多进程技术可以忽略 I/O 性能对系统性能的影响</p>
<ul>
<li>多进程技术只能提高系统吞吐率，不能减少响应时间</li>
<li>进程切换有损耗</li>
</ul>
<h2 id="RAID"><a href="#RAID" class="headerlink" title="RAID"></a>RAID</h2><blockquote>
<p>廉价磁盘冗余阵列</p>
</blockquote>
<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul>
<li>容量大</li>
<li>速度快</li>
<li>可靠性高</li>
<li>造价低廉</li>
</ul>
<h3 id="共性"><a href="#共性" class="headerlink" title="共性"></a>共性</h3><ol>
<li>RAID 由<em>一组</em>物理磁盘驱动组成，操作系统视之为<em>一个</em>逻辑驱动器</li>
<li>数据分布在一组物理磁盘上</li>
<li>冗余信息被存储再冗余磁盘空间中，保证磁盘在损坏时可以恢复数据</li>
<li>第2、3点在不同 RAID 级别中表现不同，<strong>RAID-0不支持第 3 条特性</strong></li>
</ol>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><h4 id="关键问题：如何发现磁盘失效"><a href="#关键问题：如何发现磁盘失效" class="headerlink" title="关键问题：如何发现磁盘失效"></a>关键问题：如何发现磁盘失效</h4><p>在扇区中提供故障检测操作的信息</p>
<h4 id="其它：如何减少平均修复时间MMTR"><a href="#其它：如何减少平均修复时间MMTR" class="headerlink" title="其它：如何减少平均修复时间MMTR"></a>其它：如何减少平均修复时间MMTR</h4><p>在系统中增加热备份盘</p>
<h3 id="RAID-0"><a href="#RAID-0" class="headerlink" title="RAID-0"></a>RAID-0</h3><ul>
<li>数据分块——将数据分布在多个盘上</li>
<li><strong>非冗余阵列，无冗余信息</strong></li>
<li>不是严格意义上的 RAID</li>
</ul>
<h3 id="RAID-1"><a href="#RAID-1" class="headerlink" title="RAID-1"></a>RAID-1</h3><ul>
<li>镜像盘，使用双备份磁盘</li>
<li>每当数据写入一个磁盘时，将该数据页写到另一个冗余盘</li>
</ul>
<h4 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h4><ul>
<li>读性能好</li>
<li>写性能由性能最差的磁盘决定</li>
<li>可靠性高</li>
<li>最昂贵的解决方法</li>
</ul>
<h3 id="RAID-2"><a href="#RAID-2" class="headerlink" title="RAID-2"></a>RAID-2</h3><ul>
<li>位交叉式<em>海明码</em>阵列</li>
<li>各个数据盘上相应位计算海明校验码，编码位存放在多个<em>校验磁盘</em>的对应位上</li>
</ul>
<h4 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h4><ul>
<li>并行存取，各驱动器同步工作</li>
<li>使用海明码进行检错和纠错，数据传输率高</li>
<li>需要多个磁盘存放海明码，冗余磁盘数量与数据磁盘数量的对数成正比</li>
</ul>
<h3 id="RAID-3"><a href="#RAID-3" class="headerlink" title="RAID-3"></a>RAID-3</h3><ul>
<li>位交叉奇偶校验盘阵列</li>
<li>单盘容错并行传输：数据以位/字节交叉存储，奇偶校验信息存储在专用盘上</li>
</ul>
<h4 id="特点-5"><a href="#特点-5" class="headerlink" title="特点"></a>特点</h4><ul>
<li>磁盘分组读写需要访问组中所有盘，每组中有一个校验盘</li>
<li>采用奇偶校验</li>
<li>高数据传输率，空间开销小</li>
<li>恢复时间长，不能同时支持多个 I/O 请求</li>
</ul>
<h3 id="RAID-4"><a href="#RAID-4" class="headerlink" title="RAID-4"></a>RAID-4</h3><ul>
<li>专用奇偶校验独立存取盘阵列</li>
<li>为解决 RAID-3 无法并行处理的弊端而设计</li>
<li>数据以块（块大小可变）交叉方式存于各盘，奇偶校验信息在专用盘上</li>
</ul>
<h4 id="特点-6"><a href="#特点-6" class="headerlink" title="特点"></a>特点</h4><ul>
<li>冗余代价于 RAID-3 相同</li>
<li>访问数据方法与 RAID-3 不同<ul>
<li>RAID - 3 中，一次磁盘访问将对磁盘阵列中所有磁盘进行操作</li>
<li>RAID - 4 中，一次磁盘访问只需要对磁盘阵列中某一个磁盘进行操作（不包括校验盘）</li>
</ul>
</li>
</ul>
<h3 id="RAID-5"><a href="#RAID-5" class="headerlink" title="RAID-5"></a>RAID-5</h3><ul>
<li>块交叉分布式奇偶校验盘阵列</li>
<li>数据以块（块大小可变）交叉方式存于各盘，<strong>无专用冗余盘，奇偶校验信息均匀分布在所有磁盘上</strong></li>
</ul>
<h4 id="特点-7"><a href="#特点-7" class="headerlink" title="特点"></a>特点</h4><ul>
<li>解决了 RAID-3 和 RAID-4 中，冗余盘为性能瓶颈的问题</li>
</ul>
<h3 id="RAID-6"><a href="#RAID-6" class="headerlink" title="RAID-6"></a>RAID-6</h3><ul>
<li>双维奇偶校验（P + Q 校验）独立存取盘阵列</li>
<li>数据以块（块大小可变）交叉方式存于各盘，检错和纠错信息均匀分布在所有磁盘上</li>
</ul>
<h4 id="特点-8"><a href="#特点-8" class="headerlink" title="特点"></a>特点</h4><ul>
<li>可以容忍双盘出错，提高可靠性</li>
<li>读操作与 RAID-5 类似</li>
<li>存储开销是 RAID-5 的<strong>两倍</strong></li>
<li>写过程需要 6 次磁盘操作</li>
</ul>
]]></content>
      <tags>
        <tag>review</tag>
      </tags>
  </entry>
  <entry>
    <title>解决shown.bs.modal重复触发</title>
    <url>/2021/10/14/%E8%A7%A3%E5%86%B3shown-bs-modal%E9%87%8D%E5%A4%8D%E8%A7%A6%E5%8F%91/</url>
    <content><![CDATA[<p>记录日常问题</p>
<a id="more"></a>

<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>使用Bootstrap模态框（Modal）时，选择手动打开（即<code>$(#identifier).modal(show)</code>方法）。每次打开模态框，与<code>shown.bs.modal</code>事件绑定的方法的执行次数都会比前一次加一。</p>
<blockquote>
<p>即，第一次触发<code>shown.bs.modal</code>绑定的方法调用一次，第二次触发，<strong>一次性</strong>调用两次…第n此触发，调用n次。</p>
</blockquote>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><blockquote>
<p>此处内容参考于CSDN <a href="https://blog.csdn.net/bin470398393/article/details/88398754" target="_blank" rel="noopener">https://blog.csdn.net/bin470398393/article/details/88398754</a></p>
</blockquote>
<p>代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateItem</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> item = items.find(<span class="function"><span class="keyword">function</span>(<span class="params">currentItem</span>) </span>&#123; <span class="keyword">return</span> currentItem.item_id === id&#125;);</span><br><span class="line">    <span class="keyword">var</span> itemUpdateModal = $(<span class="string">'#ItemUpdateModal'</span>);</span><br><span class="line">    itemUpdateModal.modal(<span class="string">'show'</span>);</span><br><span class="line">    </span><br><span class="line">    itemUpdateModal.on(<span class="string">'shown.bs.modal'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        $(<span class="string">'#update-footer'</span>).html(</span><br><span class="line">        <span class="string">'&lt;button type="button" class="btn btn-secondary" data-dismiss="modal"&gt;关闭&lt;/button&gt;'</span> +</span><br><span class="line">        <span class="string">'&lt;button type="button" class="btn btn-primary" onclick="updateConfirm('</span> + item.item_id + <span class="string">')"&gt;确认修改&lt;/button&gt;'</span>);</span><br><span class="line">        $(<span class="string">'#item_u_nr'</span>).val(item.nr);</span><br><span class="line">        $(<span class="string">'#item_u_dx'</span>).val(item.dx);</span><br><span class="line">        $(<span class="string">'#item_u_ssbz'</span>).val(item.ssbz);</span><br><span class="line">        $(<span class="string">'#item_u_fxdj'</span>).val(item.fxdj);</span><br><span class="line">        $(<span class="string">'#item_u_sxh'</span>).val(item.sxh);</span><br><span class="line">        <span class="keyword">if</span>(item.aqjb === <span class="string">'二级'</span>) &#123;</span><br><span class="line">            $(<span class="string">'#item_u_aqjb&gt;option'</span>)[<span class="number">0</span>].selected = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $(<span class="string">'#item_u_aqjb&gt;option'</span>)[<span class="number">1</span>].selected = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题根源在于事件绑定上：采用jQuery .on()方式绑定钩子事件，如果没有把绑定事件的函数放在最外层，就会造成<strong>多次绑定</strong>的现象发生。上述代码中，绑定函数写在了<code>updateItem()</code>方法内部，该方法与一个按钮的<code>onclick</code>事件绑定，因此，每次点击按钮，<code>shown.bs.modal</code>事件都会绑定一个匿名函数，从而造成函数的重复调用，看起来像<code>shown.bs.modal</code>事件被重复触发了一样，<strong>事实上是<code>shown.bs.modal</code>事件被绑定了n（n为按钮点击次数/updateItem()方法调用次数）个相同的匿名函数</strong>。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>解决方法有两种：</p>
<ul>
<li>将事件绑定放到最外层；</li>
<li>在与事件绑定的函数最后将事件绑定取消；</li>
</ul>
<p>第一种方法比较简单（虽然第二种也不复杂），但是如果与事件绑定的函数中需要用到某些函数的内部变量，而你又不想增加全局变量时，第二种方法显然是更好的选择；</p>
<h3 id="off"><a href="#off" class="headerlink" title=".off()"></a>.off()</h3><p>以上面的代码为例，在匿名函数最后解绑事件<code>itemUpdateModal.off(&#39;shown.bs.modal&#39;)</code>，也能避免多次调用，完整代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateItem</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> item = items.find(<span class="function"><span class="keyword">function</span>(<span class="params">currentItem</span>) </span>&#123; <span class="keyword">return</span> currentItem.item_id === id&#125;);</span><br><span class="line">    <span class="keyword">var</span> itemUpdateModal = $(<span class="string">'#ItemUpdateModal'</span>);</span><br><span class="line">    itemUpdateModal.modal(<span class="string">'show'</span>);</span><br><span class="line"></span><br><span class="line">    itemUpdateModal.on(<span class="string">'shown.bs.modal'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        $(<span class="string">'#update-footer'</span>).html(</span><br><span class="line">        <span class="string">'&lt;button type="button" class="btn btn-secondary" data-dismiss="modal"&gt;关闭&lt;/button&gt;'</span> +</span><br><span class="line">        <span class="string">'&lt;button type="button" class="btn btn-primary" onclick="updateConfirm('</span> + item.item_id + <span class="string">')"&gt;确认修改&lt;/button&gt;'</span>);</span><br><span class="line">        $(<span class="string">'#item_u_nr'</span>).val(item.nr);</span><br><span class="line">        $(<span class="string">'#item_u_dx'</span>).val(item.dx);</span><br><span class="line">        $(<span class="string">'#item_u_ssbz'</span>).val(item.ssbz);</span><br><span class="line">        $(<span class="string">'#item_u_fxdj'</span>).val(item.fxdj);</span><br><span class="line">        $(<span class="string">'#item_u_sxh'</span>).val(item.sxh);</span><br><span class="line">        <span class="keyword">if</span>(item.aqjb === <span class="string">'二级'</span>) &#123;</span><br><span class="line">            $(<span class="string">'#item_u_aqjb&gt;option'</span>)[<span class="number">0</span>].selected = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $(<span class="string">'#item_u_aqjb&gt;option'</span>)[<span class="number">1</span>].selected = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        itemUpdateModal.off(<span class="string">'shown.bs.modal'</span>);<span class="comment">//移除绑定事件的函数</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Javascript</tag>
        <tag>Bootstrap</tag>
        <tag>日常问题</tag>
      </tags>
  </entry>
  <entry>
    <title>重叠canvas元素下鼠标事件被遮挡</title>
    <url>/2022/04/02/%E9%87%8D%E5%8F%A0canvas%E5%85%83%E7%B4%A0%E4%B8%8B%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6%E8%A2%AB%E9%81%AE%E6%8C%A1/</url>
    <content><![CDATA[<p>本文对重叠元素的鼠标事件被遮挡的问题进行分析和解决</p>
<a id="more"></a>

<h1 id="重叠canvas元素下鼠标事件被遮挡的解决"><a href="#重叠canvas元素下鼠标事件被遮挡的解决" class="headerlink" title="重叠canvas元素下鼠标事件被遮挡的解决"></a>重叠canvas元素下鼠标事件被遮挡的解决</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>有两个重叠的canvas元素<code>cvs1</code>和<code>cvs2</code>，其中<code>cvs1</code>在<code>cvs2</code>上方，此时只能监听到上方canvas元素（即<code>cvs1</code>）绑定的鼠标事件，而无法监听及触发下方<code>cvs2</code>元素绑定的鼠标事件。</p>
<blockquote>
<p>此处用于分辨上下层的依据是元素的<code>z-index</code>属性</p>
</blockquote>
<h2 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h2><p>产生原因很简单，就是下方的canvas元素被上方的canvas元素遮挡，导致下方元素上不会触发鼠标事件。</p>
<h3 id="z-index"><a href="#z-index" class="headerlink" title="z-index"></a>z-index</h3><p>z-index 属性设置元素的堆叠顺序。拥有更高堆叠顺序的元素总是会处于堆叠顺序较低的元素的前面。<br>该属性设置一个<strong>定位元素</strong>沿 z 轴的位置，z 轴定义为垂直延伸到显示区的轴。如果为正数，则离用户更近，为负数则表示离用户更远。</p>
<blockquote>
<p>z-index 仅能在定位元素上奏效（例如<code>position:absolute;</code>）</p>
</blockquote>
<blockquote>
<p>定位元素：指计算后位置属性为relative,absolute,fixed或sticky的一个元素</p>
</blockquote>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><h3 id="调整元素堆叠顺序（修改z-index属性）"><a href="#调整元素堆叠顺序（修改z-index属性）" class="headerlink" title="调整元素堆叠顺序（修改z-index属性）"></a>调整元素堆叠顺序（修改z-index属性）</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>由问题产生的原因入手，很容易想到的一个解决方法便是改变两个元素的堆叠顺序，即修改两个元素的<code>z-index</code>属性。<br>假设初始状态下，<code>cvs1</code>的属性为<code>z-index = 10</code>，而<code>cvs2</code>的属性为<code>z-index = 0</code>，此时<code>cvs1</code>在<code>cvs2</code>上方，可以监听到<code>cvs1</code>上绑定的鼠标事件。<br>若需要监听<code>cvs2</code>上绑定的鼠标事件，只需要将<code>cvs2</code>的属性设置为<code>z-index = 10</code>，同时将<code>cvs1</code>的属性设置为<code>z-index = 10</code>即可，此时<code>cvs2</code>已经在<code>cvs1</code>上层，其绑定的鼠标事件便可以被触发。</p>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>这种解决方法的思路十分直接，但也存在一定的问题：<br>首先可以想到的是，如果<code>cvs2</code>元素具有非透明的背景，那么在调整堆叠顺序后，<code>cvs1</code>的内容将会完全被<code>cvs2</code>遮挡，最终会呈现出只有<code>cvs2</code>中内容的显示效果。</p>
<h3 id="设置pointer-events属性"><a href="#设置pointer-events属性" class="headerlink" title="设置pointer-events属性"></a>设置pointer-events属性</h3><h4 id="pointer-events"><a href="#pointer-events" class="headerlink" title="pointer-events"></a>pointer-events</h4><p><strong><code>pointer-events</code></strong> CSS 属性指定在什么情况下 (如果有) 某个特定的图形元素可以成为鼠标事件的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event/target" target="_blank" rel="noopener">target</a>。<br>该属性初始值为<code>auto</code>，与<code>pointer-events</code>属性未指定时的表现效果相同。</p>
<h4 id="pointer-events的none值"><a href="#pointer-events的none值" class="headerlink" title="pointer-events的none值"></a>pointer-events的none值</h4><p>当<code>pointer-events</code>属性被赋值为<code>none</code>时，元素永远不会成为鼠标事件的target。</p>
<p><strong>注意</strong>：除了指示该元素不是鼠标事件的目标之外，值<code>none</code>表示鼠标事件“穿透”该元素并且指定该元素“下面”的任何东西。</p>
<blockquote>
<p>即使在设定<code>pointer-events</code>属性值为<code>none</code>之后，当其后代元素的<code>pointer-events</code>属性指定其他值时，鼠标事件可以指向后代元素，在这种情况下，鼠标事件将在捕获或冒泡阶段触发父元素的事件侦听器。</p>
</blockquote>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>此时，事情就十分简单了，我们只需要修改上方元素<code>cvs1</code>的<code>pointer-events</code>属性值即可指定触发鼠标事件的目标元素。</p>
<ul>
<li>若需要监听<code>cvs1</code>上绑定的鼠标事件，只需要将<code>cvs1</code>的<code>pointer-events</code>属性设置为<code>auto</code>，此时处于上方的<code>cvs1</code>元素绑定的鼠标事件被正常监听和触发，而下方<code>cvs2</code>元素因为被遮挡而无法触发鼠标事件；</li>
<li>若需要监听<code>cvs2</code>上绑定的鼠标事件，只需要将<code>cvs1</code>的<code>pointer-events</code>属性设置为<code>none</code>，此时上方元素<code>cvs1</code>“被穿透”，不会作为鼠标事件的目标，而在其下方的<code>cvs2</code>元素被指定为鼠标事件的目标，其绑定的鼠标事件将被触发；</li>
</ul>
]]></content>
      <tags>
        <tag>前端</tag>
        <tag>canvas</tag>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle+MyBatis返回新插入行的主键</title>
    <url>/2021/11/07/Oracle-Mybatis%E8%BF%94%E5%9B%9E%E6%96%B0%E6%8F%92%E5%85%A5%E8%A1%8C%E7%9A%84%E4%B8%BB%E9%94%AE/</url>
    <content><![CDATA[<p>记录日常问题</p>
<a id="more"></a>

<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>开发时经常需要获取刚刚插入数据库的数据的主键值，以方便进行后续的处理。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>对不同的数据库，MyBatis对以上需求有几种实现方式：</p>
<ul>
<li>对支持主键自增的数据库（如MySQL、SQL Server），在Mapper文件的对应<code>&lt;select&gt;</code>标签中添加<code>keyProperty</code>和<code>useGeneratedKeys</code>属性；</li>
<li>对不支持主键自增的数据库（如Oracle），在Mapper文件的对应<code>&lt;select&gt;</code>标签中添加<code>&lt;selectKey&gt;</code>标签；</li>
</ul>
<h3 id="支持主键自增的数据库"><a href="#支持主键自增的数据库" class="headerlink" title="支持主键自增的数据库"></a>支持主键自增的数据库</h3><p>MySQL、SQL Server等数据库支持主键自增，则只需要在<code>&lt;select&gt;</code>标签中添加<code>keyProperty</code>和<code>useGeneratedKeys</code>属性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;insert id&#x3D;&quot;foo&quot; parameterType&#x3D;&quot;bar&quot; useGeneratedKeys&#x3D;”true” keyProperty&#x3D;”主键名”&gt;</span><br><span class="line">　　insert 语句</span><br><span class="line">&lt;&#x2F;insert&gt;</span><br></pre></td></tr></table></figure>
<p>需要注意，<code>keyProperty</code>的值并不是数据库中表的主键名，而是<strong>Java对象中与主键对应的变量名</strong></p>
<h3 id="不支持主键自增的数据库"><a href="#不支持主键自增的数据库" class="headerlink" title="不支持主键自增的数据库"></a>不支持主键自增的数据库</h3><p>对于Oracle这种不支持主键自增的数据库，可以用sequence自动生成序列号来作为主键，并且在对应表的insert事件上添加触发器</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">trigger</span> 触发器名</span><br><span class="line"><span class="keyword">before</span> <span class="keyword">insert</span> <span class="keyword">on</span> 表名 <span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span> </span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">select</span> <span class="keyword">sequence</span>名.nextval <span class="keyword">into</span>:new.主键名 <span class="keyword">from</span> dual;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<p>该触发器在每次插入时触发，对插入的每行都执行一次</p>
<h4 id="关于sequence，以及它的nextval和currval"><a href="#关于sequence，以及它的nextval和currval" class="headerlink" title="关于sequence，以及它的nextval和currval"></a>关于sequence，以及它的nextval和currval</h4><p>通过以下语句创建sequence：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">sequence</span> 序列名  </span><br><span class="line"><span class="keyword">INCREMENT</span> <span class="keyword">BY</span> <span class="number">1</span> <span class="comment">-- 每次加1  </span></span><br><span class="line"><span class="keyword">START</span> <span class="keyword">WITH</span> <span class="number">1</span> <span class="comment">-- 从1开始计数  </span></span><br><span class="line"><span class="keyword">NOMAXVALUE</span> <span class="comment">-- 不设置最大值  </span></span><br><span class="line"><span class="keyword">NOCYCLE</span> <span class="comment">-- 一直累加，不循环  </span></span><br><span class="line"><span class="keyword">CACHE</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>nextval：取下一个序列值，sequence会自动增加，增加值由创建语句中的<code>INCREMENT BY</code>决定；</li>
<li>currval：取当前序列值，且sequence<strong>不会</strong>增加；</li>
</ul>
<h4 id="获得主键"><a href="#获得主键" class="headerlink" title="获得主键"></a>获得主键</h4><p>添加<code>&lt;selectKey&gt;</code>标签：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&lt;insert id="foo" parameterType="bar"&gt;</span><br><span class="line">        &lt;selectKey keyProperty="主键名" resultType="Integer" order="AFTER"&gt;</span><br><span class="line">            <span class="keyword">select</span> ITEMid_sequence.CURRVAL <span class="keyword">from</span> dual</span><br><span class="line">        &lt;/selectKey&gt;</span><br><span class="line">        <span class="keyword">INSERT</span> 语句</span><br><span class="line">    &lt;/<span class="keyword">insert</span>&gt;</span><br></pre></td></tr></table></figure>
<p><code>&lt;selectKey&gt;</code>标签中的属性值<code>order=&quot;AFTER&quot;</code>表示该语句在insert语句执行完成后执行，设置AFTER的原因是让绑定在insert语句上的触发器先执行。触发器取nextval，得到sequence的下一个值作为主键值，之后sequence自动增加，此时sequence值正好等于当前插入行的主键值，所以使用currval取得当前sequence值，确保取到的值和插入行的主键值一致；</p>
<h2 id="取主键值"><a href="#取主键值" class="headerlink" title="取主键值"></a>取主键值</h2><p>以上操作<strong>并不会修改与SQL语句绑定的方法的返回值</strong>，那么他们实际上做了什么呢？<br>事实上，无论是添加<code>keyProperty</code>和<code>useGeneratedKeys</code>属性，还是添加<code>&lt;selectKey&gt;</code>标签，实际上都是将取得的主键值填入了传入参数的对应变量中。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>假设一个Java对象为User，有如下属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> user_id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>user_id为主键字段对应的类属性，现在用上文所述操作实现了该对象的插入方法<code>insertUser(User user)</code>。<br>通过以下语句获取主键值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">user.setName(<span class="string">'Test'</span>);</span><br><span class="line">insertUser(user);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> keyValue = user.getUser_id();</span><br></pre></td></tr></table></figure>
<p><code>keyValue</code>即为新插入行的主键值。</p>
<p>如此便可以理解为什么<code>keyProperty</code>的值需要填Java对象中与主键对应的变量名，因为主键值取到后不是填入数据库中，而是要填入Java对象中，所以取主键值也应当在传入的对象中取得。</p>
]]></content>
      <tags>
        <tag>后端</tag>
        <tag>日常问题</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>图像处理_1</title>
    <url>/2021/11/29/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-1/</url>
    <content><![CDATA[<p>本篇主要介绍网页端图像处理的一些前置内容</p>
<a id="more"></a>

<h1 id="网页端图像处理"><a href="#网页端图像处理" class="headerlink" title="网页端图像处理"></a>网页端图像处理</h1><h2 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h2><h3 id="canvas概念"><a href="#canvas概念" class="headerlink" title="canvas概念"></a>canvas概念</h3><ul>
<li>canvas 是HTML5的元素，用于在网页上绘制图形。</li>
<li>canvas 是一个矩形区域，该区域的每一个像素都能被获取和修改。</li>
<li>canvas 元素本身没有绘图能力，所有的绘制工作交由<code>Javascript</code>完成。</li>
<li>canvas 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。</li>
</ul>
<h3 id="canvas基本使用"><a href="#canvas基本使用" class="headerlink" title="canvas基本使用"></a>canvas基本使用</h3><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p>使用<code>&lt;canvas&gt;&lt;/canvas&gt;</code>标签向网页添加canvas元素，使用<code>height</code>、<code>width</code>属性设置元素的宽高。<br>如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"myCanvas"</span> <span class="attr">width</span>=<span class="string">"200"</span> <span class="attr">height</span>=<span class="string">"100"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h4><p>在JS内完成绘制：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="keyword">var</span> c=<span class="built_in">document</span>.getElementById(<span class="string">"myCanvas"</span>);</span><br><span class="line"><span class="keyword">var</span> cxt=c.getContext(<span class="string">"2d"</span>);</span><br><span class="line">cxt.fillStyle=<span class="string">"#FF0000"</span>;</span><br><span class="line">cxt.fillRect(<span class="number">0</span>,<span class="number">0</span>,<span class="number">150</span>,<span class="number">75</span>);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>getContext(“2d”) 对象是内建的 HTML5 对象，拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。</strong></p>
<blockquote>
<p>更多方法详见<a href="https://www.w3school.com.cn/tags/html_ref_canvas.asp" target="_blank" rel="noopener">https://www.w3school.com.cn/tags/html_ref_canvas.asp</a></p>
</blockquote>
<h2 id="ImageData"><a href="#ImageData" class="headerlink" title="ImageData"></a>ImageData</h2><p>ImageData是一个对象，其描述描述<code>&lt;canvas&gt;</code>元素的一个隐含像素数据的区域。这么说可能有点抽象，我们直接来看它的属性：</p>
<blockquote>
<ul>
<li>data：一维数组，包含以 RGBA 顺序的数据，数据使用  0 至 255（包含）的整数表示。 </li>
</ul>
</blockquote>
<ul>
<li>height：无符号长整形，使用像素描述 ImageData 的实际高度。</li>
<li>width：无符号长整型，使用像素描述 ImageData 的实际宽度。</li>
</ul>
<p>如此一来，我们便知道了ImageData的作用了：它将canvas中某个区域（注意<strong>不是整个canvas</strong>），内的图像信息以RGBA的形式存储在<code>data</code>属性中，同时存储这块区域的宽高信息。<br>对于<code>data</code>属性，还需要做一些补充说明：<code>data</code>数组的每个元素并不代表一个像素点，从定义可以看出，图像信息是<em>以RGBA顺序</em>存储的，即<strong>每4个元素为一个像素点的所有信息</strong>。</p>
<blockquote>
<p>关于RGBA中的A：指alpha 通道，取值为0-255; 0 是透明的，255 是完全可见的</p>
</blockquote>
<h3 id="ImageData基本方法"><a href="#ImageData基本方法" class="headerlink" title="ImageData基本方法"></a>ImageData基本方法</h3><p>下文介绍的几个方法均封装在<code>CanvasRenderingContext2D</code>对象中。<br><code>CanvasRenderingContext2D</code>对象接口是Canvas API的一部分，可为<code>&lt;canvas&gt;</code>元素的绘图表面提供2D渲染上下文，它用于绘制形状，文本，图像和其他对象。上文提到的<code>getContext()</code>方法的返回值就是该对象，有了上下文（也可以说是绘图环境）才能使用Javascript在canvas上进行绘制。</p>
<h4 id="创建ImageData：createImageData"><a href="#创建ImageData：createImageData" class="headerlink" title="创建ImageData：createImageData()"></a>创建ImageData：createImageData()</h4><p>createImageData() 方法创建新的空白 ImageData 对象。新对象的默认像素值 transparent black。</p>
<blockquote>
<p>transparent black 表示 (0,0,0,0)</p>
</blockquote>
<p>语法：</p>
<blockquote>
<p>//以指定的尺寸（以像素计）创建新的 ImageData 对象<br>ImageData ctx.createImageData(width, height);<br>//创建与指定的另一个 ImageData 对象尺寸相同的新 ImageData 对象（不会复制图像数据)<br>ImageData ctx.createImageData(imagedata);</p>
</blockquote>
<h4 id="获取ImageData：getImageData"><a href="#获取ImageData：getImageData" class="headerlink" title="获取ImageData：getImageData()"></a>获取ImageData：getImageData()</h4><p>该方法返回一个<code>ImageData</code>对象，用来描述canvas区域隐含的像素数据，这个区域通过矩形表示，起始点为(sx, sy)、宽为sw、高为sh。</p>
<p>语法：</p>
<blockquote>
<p>ImageData ctx.getImageData(sx, sy, sw, sh);</p>
</blockquote>
<h4 id="绘制：putImageData"><a href="#绘制：putImageData" class="headerlink" title="绘制：putImageData()"></a>绘制：putImageData()</h4><p>该方法将数据从已有的<code>ImageData</code>对象绘制到位图。如果提供了一个绘制过的矩形，则只绘制该矩形的像素。此方法不受画布转换矩阵的影响。</p>
<p>语法：</p>
<blockquote>
<p>void ctx.putImageData(imagedata, dx, dy);<br>void ctx.putImageData(imagedata, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight);</p>
</blockquote>
<blockquote>
<p>该方法更多细节见<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/putImageData" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/putImageData</a></p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在掌握了上文内容后，我们便拥有了进行图像处理的基本条件。现在我们能获得一张图片所有像素点的信息、同时我们也知道如何将包含所有像素点信息的对象绘制到<code>&lt;canvas&gt;</code>上，如果把图像处理看成一个功能模块，现在我们已经实现了该模块的输入和输出。<br>下章将会介绍一些基本的滤镜算法。</p>
]]></content>
      <tags>
        <tag>前端</tag>
        <tag>canvas</tag>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>事件派发和DOM事件流</title>
    <url>/2022/04/11/%E4%BA%8B%E4%BB%B6%E6%B4%BE%E5%8F%91%E5%92%8CDOM%E4%BA%8B%E4%BB%B6%E6%B5%81/</url>
    <content><![CDATA[<p>本篇简单介绍DOM事件的一些基础概念</p>
<a id="more"></a>



<h2 id="事件派发"><a href="#事件派发" class="headerlink" title="事件派发"></a>事件派发</h2><p>应用程序可以使用<code>dispatchEvent()</code>方法来派发事件对象，事件对象将按照DOM事件流决定的方式在DOM树中传播。</p>
<h3 id="EventTarget-dispatchEvent"><a href="#EventTarget-dispatchEvent" class="headerlink" title="EventTarget.dispatchEvent"></a>EventTarget.dispatchEvent</h3><p>该方法向一个指定的事件目标派发一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event" target="_blank" rel="noopener">事件</a>, 并以合适的顺序<strong>同步调用</strong>目标元素相关的事件处理函数。标准事件处理规则(包括事件捕获和可选的冒泡过程)同样适用于通过手动的使用<code>dispatchEvent()</code>方法派发的事件。</p>
<h2 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h2><p>事件对象被派发到一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget" target="_blank" rel="noopener">事件目标(EventTarget)</a>。但在派发开始之前，必须首先确定事件对象的传播路径。</p>
<blockquote>
<p><code>EventTarget</code> 是一个 DOM 接口，由可以接收事件、并且可以创建侦听器的对象实现。</p>
<p><code>Element</code>，<code>document</code> 和 <code>window</code> 是最常见的 event targets ，但是其他对象也可以作为 event targets，比如 <code>XMLHttpRequest</code>，<code>AudioNode</code>，<code>AudioContext</code>  等等。</p>
</blockquote>
<p>传播路径是事件所经过的当前事件目标的一个有序列表。这个传播路径反映了文档的层次树形结构。列表中的<strong>最后一项</strong>是事件目标，列表中前面的元素被称为事件目标的祖先，紧跟在事件目标之前的元素（即倒数第二个元素）是目标的父级。</p>
<p>一旦传播路径被确定，事件对象会经过一个<em>或</em> 多个事件阶段。</p>
<h3 id="事件阶段"><a href="#事件阶段" class="headerlink" title="事件阶段"></a>事件阶段</h3><table>
<thead>
<tr>
<th align="left">阶段</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">捕获阶段</td>
<td align="left">事件正在被目标元素的祖先对象处理. 这个处理过程从<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window" target="_blank" rel="noopener"><code>Window</code></a>开始，然后<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document" target="_blank" rel="noopener"><code>Document</code></a>, 然后是<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLHtmlElement" target="_blank" rel="noopener"><code>HTMLHtmlElement</code></a>, 一直这样，直到目标元素的父元素。 通过<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener" target="_blank" rel="noopener"><code>EventTarget.addEventListener()</code></a> 注册为捕获模式的<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventListener" target="_blank" rel="noopener">Event listeners</a> 被调用。</td>
</tr>
<tr>
<td align="left">目标阶段</td>
<td align="left">事件对象已经抵达事件目标（EventTarget）. 为这个阶段注册的事件监听被调用。 如果 <code>Event.bubbles</code>的值为<code>false</code>, 对事件对象的处理在这个阶段后就会结束.</td>
</tr>
<tr>
<td align="left">冒泡阶段</td>
<td align="left">事件对象逆向向上传播回目标元素的祖先元素, 从父亲元素开始，并且最终到达包含元素 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window" target="_blank" rel="noopener"><code>Window</code></a>。只有<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event/bubbles" target="_blank" rel="noopener"><code>Event.bubbles</code></a> 值为<code>true</code>的时候才会发生。 为这个阶段注册的<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventListener" target="_blank" rel="noopener">Event listeners</a> 在这个过程中被触发.</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>事件捕获和事件冒泡</title>
    <url>/2022/04/11/%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1/</url>
    <content><![CDATA[<p>本文介绍关于事件捕获和冒泡的相关概念</p>
<a id="more"></a>

<p>内容参考MDN文档：<a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Building_blocks/Events#%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E5%8F%8A%E6%8D%95%E8%8E%B7" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Building_blocks/Events#%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E5%8F%8A%E6%8D%95%E8%8E%B7</a></p>
<h1 id="事件冒泡及捕获"><a href="#事件冒泡及捕获" class="headerlink" title="事件冒泡及捕获"></a>事件冒泡及捕获</h1><blockquote>
<p>事件冒泡和捕捉是两种机制，主要描述当在一个元素上有两个相同类型的事件处理器被激活会发生什么。</p>
</blockquote>
<p>干讲很抽象，这里引入一个例子：<br><img src="/2022/04/11/%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1/examplePage.jpg" alt></p>
<p>如上图，页面中有两个div元素<code>div-parent</code>和<code>div-child</code>，深灰色区域为外层div元素<code>div-parent</code>，浅灰色区域为内层div元素<code>div-child</code>。现在为两个div元素都添加一个事件处理器：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> divParent = <span class="built_in">document</span>.getElementById(<span class="string">'div-parent'</span>);</span><br><span class="line"><span class="keyword">var</span> divChild = <span class="built_in">document</span>.getElementById(<span class="string">'div-child'</span>);</span><br><span class="line"></span><br><span class="line">divParent.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'parent'</span>);</span><br><span class="line">&#125;;</span><br><span class="line">divChild.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'child'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当点击深灰色区域时，控制台只会输出‘parent’，这点自不必说。需要注意的是在点击浅色区域时，控制台会<strong>先后输出</strong>‘child’和‘parent’，如下图：<br><img src="/2022/04/11/%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1/clickResponse.jpg" alt></p>
<p>造成这种现象的原因便是<strong>事件冒泡</strong></p>
<h2 id="对事件冒泡和捕捉的解释"><a href="#对事件冒泡和捕捉的解释" class="headerlink" title="对事件冒泡和捕捉的解释"></a>对事件冒泡和捕捉的解释</h2><p>当一个事件发生在具有父元素的元素上时，现代浏览器运行两个不同的阶段，即<strong>捕获阶段</strong>和<strong>冒泡阶段</strong>。</p>
<h3 id="捕获阶段"><a href="#捕获阶段" class="headerlink" title="捕获阶段"></a>捕获阶段</h3><ul>
<li>浏览器检查元素的最外层祖先<code>&lt;html&gt;</code>，是否在捕获阶段中注册了一个事件处理程序（本例中该事件为<code>onclick</code>），如果是，则运行它。</li>
<li>然后，它移动到<code>&lt;html&gt;</code>中单击元素的下一个祖先元素，并执行相同的操作，然后是单击元素再下一个祖先元素，依此类推，直到到达实际点击的元素。</li>
</ul>
<h3 id="冒泡阶段"><a href="#冒泡阶段" class="headerlink" title="冒泡阶段"></a>冒泡阶段</h3><ul>
<li>浏览器检查实际触发事件（本例中触发的事件为点击事件）的元素是否在冒泡阶段中注册了一个对应的事件处理程序（本例中为<code>onclick</code>），如果是，则运行它。</li>
<li>然后它移动到下一个<strong>直接</strong>的祖先元素，并做同样的事情，然后是下一个，等等，直到它到达<code>&lt;html&gt;</code>元素。</li>
</ul>
<p>用图片来解释，事件捕获和事件冒泡流程如下：</p>
<p><img src="/2022/04/11/%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1/captureNbubble.jpg" alt></p>
<p>可以看到，事件捕获（Event Capturing）和事件冒泡（Event Bubbling）的顺序正好是相反的。在现代浏览器中，默认情况下，所有事件处理程序都在<strong>冒泡阶段</strong>进行注册。</p>
<h2 id="阻止事件传播"><a href="#阻止事件传播" class="headerlink" title="阻止事件传播"></a>阻止事件传播</h2><p>我们有时候会不希望事件对象向父元素的方向进行传播（比如<a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Building_blocks/Events#%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E5%8F%8A%E6%8D%95%E8%8E%B7" target="_blank" rel="noopener">MDN</a>中给出的例子），此时可以使用<code>stopPropagation()</code>方法解决这个问题。</p>
<h3 id="stopPropagation"><a href="#stopPropagation" class="headerlink" title="stopPropagation()"></a>stopPropagation()</h3><p>该方法是标准事件对象自带的方法，当在事件对象上调用该函数时，它只会让当前事件处理程序运行，但事件不会在<strong>冒泡</strong>链上进一步扩大，因此将不会执行其他的事件处理器(不会向上冒泡)。</p>
<p>因此，对上例中的代码稍作修改：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">divChild.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  	e.stopPropagation();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'child'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，再点击内侧元素，控制台只输出‘child’：<img src="/2022/04/11/%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1/clickNew.jpg" alt></p>
<h3 id="Event-bubbles"><a href="#Event-bubbles" class="headerlink" title="Event.bubbles"></a>Event.bubbles</h3><p>可以通过设置事件对象的<code>bubbles</code>属性来跳过事件流的冒泡阶段，关于事件流，详见<a href="https://www.w3.org/TR/DOM-Level-3-Events/#event-flow" target="_blank" rel="noopener">此处</a>，或者本站的另一篇博文<a href>事件派发和事件流</a>.</p>
<p><strong>需要注意：</strong>在事件触发之后的回调函数中设置事件的<code>bubbles</code>属性<strong>并不能</strong>阻止事件的冒泡，需要在事件派发之前，即创建事件对象的时候就设置。</p>
<p>事件对象的构造函数如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">event = <span class="keyword">new</span> Event(typeArg, eventInit);</span><br></pre></td></tr></table></figure>

<p>其参数：</p>
<h5 id="typeArg"><a href="#typeArg" class="headerlink" title="typeArg"></a><em>typeArg</em></h5><p><code>DOMString</code> 类型，表示所创建事件的名称。</p>
<h5 id="eventInit"><a href="#eventInit" class="headerlink" title="eventInit"></a><em>eventInit</em></h5><p>是 <code>EventInit</code> 类型的字典，接受以下字段:</p>
<ul>
<li><code>&quot;bubbles&quot;</code>，可选，<code>Boolean</code>类型，默认值为 <code>false</code>，表示该事件是否冒泡。</li>
<li><code>&quot;cancelable&quot;</code>，可选，<code>Boolean</code>类型，默认值为 <code>false</code>， 表示该事件能否被取消。</li>
<li><code>&quot;composed&quot;</code>，可选，<code>Boolean</code>类型，默认值为 <code>false</code>，指示事件是否会在影子DOM根节点之外触发侦听器。</li>
</ul>
<h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2><p>如果想要在大量子元素中单击任何一个都可以运行一段代码，可以<em>将事件监听器设置在其父节点上</em>，并让子节点上发生的事件冒泡到父节点上，而不是每个子节点单独设置事件监听器。</p>
<blockquote>
<p>一个很好的例子是一系列列表项，如果你想让每个列表项被点击时弹出一条信息，您可以将<code>click</code>单击事件监听器设置在父元素<code>&lt;ul&gt;</code>上，这样事件就会从列表项冒泡到其父元素<code>&lt;ul&gt;</code>上。</p>
<p>这个的概念在David Walsh的博客上有更多的解释，并有多个例子——看看<a href="https://davidwalsh.name/event-delegate" target="_blank" rel="noopener">How JavaScript Event Delegation Works</a>.</p>
</blockquote>
]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
</search>
